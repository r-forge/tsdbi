\documentclass[english]{article}
\usepackage{natbib}
\usepackage{url}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}
\newcommand{\code}{\emph}
\newcommand{\pkg}{\textsl}
\newcommand{\proglang}{\textsl}
%% If the size of graphs is not set, the default is 6x6. 
%%  4x7 works well for graphs with a single panel, 
%%  but needs to be over-ridden for multi-panel graphs.
\SweaveOpts{eval=TRUE,echo=TRUE,results=hide,fig=FALSE,width=7.0,height=4}
%\SweaveOpts{eval=TRUE,echo=TRUE,results=verbatim,fig=TRUE}
%\VignetteIndexEntry{Guide: TSdbi Interface Illustrations}
\begin{document}
\begin{titlepage}
\begin{center}
{\huge Time Series Database Interface (TSdbi) Illustrations}\\[0.75cm]
{\Large Paul D. Gilbert}\\[0.2cm]
{\Large \today}\\[0.5cm]
\end{center}
\tableofcontents
\end{titlepage}
\begin{Scode}{echo=FALSE,results=hide}
 options(continue="  ")
\end{Scode}
%%
\section{Introduction}
\label{sec:Intro}
%%
This vignette illustrates the various \proglang{R} \citep{R} \pkg{TSdbi} 
packages using time series 
data from several sources. The main purpose of \pkg{TSdbi} is to provide a
common \emph{API}, so simplicity of changing the data source is a primary
feature. 
The vignette also illustrates some simple time series
manipulation and plotting using packages \pkg{tframe} and \pkg{tfplot}.

To generate this vignette requires most of the \pkg{TS*} packages, but 
users will only need one, or a few of these packages. For example, a time series
database can be built with several SQL database backends, 
but typically only one would be used. 
On the other hand, several packages pull data from 
various Internet sources, so several of these might be used to accommodate the
various specifics of the sources.

If package \pkg{TSdata} is installed on your system, it should be possible 
to view the pdf version of this guide 
with \emph{vignette("Guide", package="TSdata")}. Otherwise, consider 
getting the pdf file directly from CRAN at 
\url{http://cran.at.r-project.org/web/packages/TSdata/index.html} 
Many parts
of the vignette can be run by loading the appropriate packages, but some
examples use data that has been loaded into a larger database 
and it will not be possible to reproduce those examples without the
underlying database.

Section \ref{sec:SimpleExamples} of this vignette illustrates the mechanism for
connecting to a data source. The connection contains all the source specific 
information so, once the connection is established, the syntax for retrieving
data is similar for different sources.
The section also illustrates packages that 
pull data from Internet sources. This currently includes \pkg{TSgetSymbol}, 
\pkg{TShistQuote}, \pkg{TSxls}, and \pkg{TSzip}, but others are in progress.
These packages only get data, they do not support writing data to the database.
Finally, the section also illustrates the flexibility to return different types
of time series objects.

Section \ref{sec:SQL} illustrates the SQL packages \pkg{TSPostgreSQL}, 
\pkg{TSMySQL}, \pkg{TSSQLite}, and \pkg{TSodbc}. These use a very standard SQL
table structure and syntax, so it should be possible to use other SQL backends.
The package \pkg{TSOracle} is available on R-forge at 
\url{http://tsdbi.r-forge.r-project.org/} but I currently do not have a server
in place to test it properly. (If anyone would be interested in doing this,
please contact me, pgilbert.ttv9z@ncf.ca.)
These packages get data and also support writing data to the database.
See Appendix ``B'' (section \ref{appdx:B}) and the vignette in package \pkg{TSdbi} for more explanation 
of the underlying database tables, and for bulk loading of
data into a database.
The section illustrates writing artificial data to the database. 

Section \ref{sec:MoreExamples} provides additional examples of \pkg{TSdbi}
functionality and of using and graphing series. 
Subsection \ref{sec:SQLexamples} illustrates fetching data from the web and 
loading it into a local database.
Subsection \ref{sec:etsExamples} provides examples of how one might use a
more extensively populated database that has been previously constructed.

Section \ref{sec:Comparing} illustrates package \pkg{TScompare} for comparing 
time series databases, and Section \ref{sec:Vintages} illustrates the use of
realtime vintages of data.

Appendix ``A'' provides connection details specific to the different
database sources,
Appendix ``B'' provides more details about the structure of SQL
databases
and, finally, Appendix ``C'' provides some examples of SQL queries that
may be useful for database maintenance.

Many of the \pkg{TS*} packages are wrappers of other packages. The purpose is to
provide a common API for interfacing with time series databases, and an easy 
mechanism to specify the type of time series object that should be returned, for
example, a \code{ts} object or a \code{zoo} \citep{zoo} object. One consequence of providing
a common interface is that special strengths of some of the underlying packages
cannot always be used. If you really need some of these features then you may
need to go directly to the underlying package. However, if you limit your
reliance on these underlying features then you will be able to move from one
data source to another much more easily.

Loading a \pkg{TS*} package will also load required packages \pkg{TSdbi}, 
\pkg{DBI} \citep{DBI}, \pkg{methods}, \pkg{tframePlus}, 
\pkg{zoo}, and then any underlying package that the specific \pkg{TS*} package uses.

%%
\section{Simple Examples of Time Series Data from the Internet}
\label{sec:SimpleExamples}
%%
This section uses packages to pull data
from the Internet. The general syntax of a connection is illustrated, and
some simple calculations and graphs are done to demonstrate how the data 
might be used.
However, the purpose of the \pkg{TS*} packages is to provide a common interface,
not to do all time series calculations and graphics. Once you have the data, 
you should be able to use whatever other \pkg{R} 
packages you like for your calculations and graphs.

The generic aspect of the interface API is accomplished by putting the
information specific to the underlying source into the ``connection''. Once the
connection is established, other aspects of using data are the same, so one
connection can be easily interchanged with another, and so your programs do not
need to be changed when the data source is changed. (But, of course, some
changes will be needed if the names of the variables change.) 
%%
\subsection{\pkg{TShistQuote} and \pkg{TSgetSymbol}}
%%
Packages \pkg{TShistQuote} and \pkg{TSgetSymbol}  provide mechanisms to retrieve
historical quote data from various sources. 
\pkg{TShistQuote} is a wrapper to \code{get.hist.quote} in package
\pkg{tseries} \citep{tseries}. A connection to Yahoo Finance is established, and data 
retrieved and plotted by

\begin{Scode}{results=verbatim,fig=TRUE}
  library("TShistQuote")  
  yahoo <- TSconnect("histQuote", dbname="yahoo") 
  x <- TSget("^gspc", quote = "Close", con=yahoo)
  library("tfplot")  
  tfplot(x)
\end{Scode}

Package \pkg{TSgetSymbol} is a wrapper to \code{getSymbols} in package
\pkg{quantmod} \citep{quantmod}. A connection to Yahoo using this, and
retrieving the same data, can be done by

\begin{Scode}{results=verbatim,fig=TRUE}
  library("TSgetSymbol")  
  yahoo <- TSconnect("getSymbol", dbname="yahoo") 
  x <- TSget("^gspc", quote = "Close", con=yahoo)
  tfplot(x)
\end{Scode}

Notice that the only difference is the library that is loaded and the name of
the driver provided when establishing the connection. After that, the code is the
same (and the data from the two connections should be the same). This is the
coding approach one would typically follow, so that changing the data source is
easy. However, sometimes it is interesting to compared the same data from 
differrent sources, so here is an example where the connections are given 
different names, so the same data through two different connection
methods can be more easily compared:
\begin{Scode}{results=verbatim,fig=FALSE}
ya1 <- TSconnect("getSymbol", dbname="yahoo")
ya2 <- TSconnect("histQuote", dbname="yahoo")
ibmC1 <- TSget("ibm", ya1, quote = "Close", start="2011-01-03")
ibmC2 <- TSget("ibm", ya2, quote = "Close", start="2011-01-03")
\end{Scode}

In this example the underlying packages both return \code{zoo} time series
objects, but the encoding of the date index vectors  
are of different classes (\code{Date} vs \code{POSIXct}). This is usually 
not a problem
because one would usually work with one package or the other, but it does become
a problem when comparing the two objects returned by the different methods.
The time representation of \code{ibmC1} can be changed from \code{POSIXct} 
to \code{Date} by:
\begin{Scode}{results=verbatim,fig=FALSE}
tframe(ibmC1) <- as.Date(tframe(ibmC1))
\end{Scode}

The two series can then be plotted:
\begin{Scode}{results=verbatim,fig=TRUE}
tfplot(ibmC2, ibmC1,  
   ylab="IBM Close",
   Title="IBM via getSymbol and histQuote",
   lastObs=TRUE, 
   legend=c("via histQuote (black)", "via getSymbol (red)"),
   source="Source: Yahoo")
\end{Scode}

Or the difference can be used to check equality:
\begin{Scode}{results=verbatim}
max(abs(ibmC2 - ibmC1))
\end{Scode}

(Note that this difference calculation does not catch a difference in length, 
which occurs if new data has been release on one connection and not the other. 
At some point Yahoo was releasing partial data early, and these connection are
correcting differently for this. So, at some times of day, the last available
data point is not the same on these two connections.)

A certain amount of meta data can be returned with the time series object 
and can be extracted with these utilities:
\begin{Scode}{results=verbatim,fig=FALSE}
  TSdescription(x) 
  TSdoc(x) 
  TSlabel(x) 
  TSsource(x) 
\end{Scode}
%%
%%
\subsection{\pkg{TSgetSymbol} with FRED}

Package \pkg{TSgetSymbol} can also be used to get data from the Federal Reserve 
Bank of St.Louis, as will be illustrated here. 
(Look at \url{http://research.stlouisfed.org/fred/} to find series identifiers.)

\begin{Scode}{fig=TRUE}
  library("TSgetSymbol")  
  fred <- TSconnect("getSymbol", dbname="FRED") 
  tfplot(TSget("M2", fred))
\end{Scode}

A connection can be specified to be used as the default, so it does not need to
be specified each time:

\begin{Scode}{fig=TRUE}
  options(TSconnection=fred)
  tfOnePlot(percentChange(TSget("M2"), lag=52), 
    Title = "Running commentary, blah, blah, blah", 
    subtitle="Broad Money (M2)",
    ylab= "y/y percent change*",
    source="Source: Federal Reserve Bank of St.Louis (M2)",
    footnoteLeft = "seasonally adjusted data",
    footnoteRight = "* approximated by 52 week growth",
    lastObs = TRUE )
\end{Scode}

Several different connections will be used in this vignette, and so a default
will not be used. To unset the default
\begin{Scode}
  options(TSconnection=NULL)
\end{Scode}

It is also possible to return multiple series, but they should all be of the
same frequency. (The FRED series called M2 is a weekly series). 

\begin{Scode}{fig=TRUE,height=8}
  x <- TSget(c("CPIAUCNS","M2SL"), fred)
  tfplot(x, 
    Title = "Running commentary, blah, blah, blah", 
    subtitle=c("Consumer Price Index for All Urban Consumers: All Items", "Broad Money"),
    ylab= c("Index 1982-84=100", "Billions of dollars"),
    source= c("Data Source: Federal Reserve Bank of St.Louis (CPIAUCNS)",
              "Data Source: Federal Reserve Bank of St.Louis (M2SL)"),
    footnoteLeft  = c("not seasonally adjusted",  "seasonally adjusted"),
    footnoteRight = paste("Extracted:", date()),
    lastObs = TRUE )
\end{Scode}


\begin{Scode}{results=verbatim,fig=FALSE}
  TSdates(c("CPIAUCNS","M2SL"), fred) 
\end{Scode}

By default, \code{TSget} returns \code{ts} time series for annual, quarterly,
and monthly data, and \code{zoo} series otherwise. It is possible to specify the
type of object to return:

\begin{Scode}
  x <- TSget(c("CPIAUCNS","M2SL"), fred, TSrepresentation="zoo")
  class(x) 
\end{Scode}

A session default can also be set for this with
\begin{Scode}
  options(TSrepresentation="zoo")
\end{Scode}
in which case all results will be return as \code{zoo} objects unless otherwise
specified. The session default is unset with
\begin{Scode}
  options(TSrepresentation=NULL)
\end{Scode}
Beware that it does not make sense to set \code{ts} as the default, because it
is already the default for all series that can be represented as \code{ts}, and
will not work correctly for other series.
Other representations are possible. See the \code{TSget} help for 
more details. 

The following connects to yahoo and loads the ticker symbol for Ford. 
This is a multivariate time series with open, close, etc.
\begin{Scode}{fig=TRUE,height=8}
  yahoo <- TSconnect("getSymbol", dbname="yahoo") 
  x <- TSget("F", con=yahoo)
  plot(x)
\end{Scode}

Most of the plots in this vignette are done with the utilities in the 
\pkg{tfplot} package, but the usual \code{plot} function, used above,
produces slightly different results that may be preferable in some situations.
Also, for some time series objects, the plot method has been much improved from
the default, so if you are using these objects you may find that \code{plot} 
provides attractive features. 

In the case of the ticker data above, \code{tfplot} displays graphs in verticle 
panels. However, six panels do not nicely fit on a printed page. 
The first three are displayed with:
\begin{Scode}{fig=TRUE,height=12}
  tfplot(x,series=1:3)
\end{Scode}

It is possible to specify the number of graphs on an ouput screen
with \code{graphs.per.page}, for example, \code{tfplot(x, graphs.per.page=3)}. 
Set \code{par(ask=TRUE)} if 
you want to stop and prompt for <Return> between pages in the graphics output.

The \code{quote} argument to \code{TSget} can be used to specify that only a 
subset of the market data should be returned:
\begin{Scode}{fig=TRUE}
  tfOnePlot(TSget("F", con=yahoo, quote=c("Open", "Close")),
     Title="Ford from Yahoo;  Open (black); Close (red)",
     ylab="Price")
\end{Scode}
%%
%%
\subsection{TSxls}
%%
\pkg{TSxls} provides methods for the \pkg{TSdbi} interface, allowing the 
use of spreadsheets as if they are a database. (This is a poor substitute 
for a real database, but is sometimes convenient.) 
\pkg{TSxls} uses package \code{read.xls} in \pkg{gdata} \citep{gdata}
\pkg{TSxls} does not support writing data to the spreadsheet (but 
see \code{TSwriteXLS} in \pkg{tframePlus} to write time series data into a 
spreadsheet). The spreadsheet can be a 
remote file, which is retrieved when the connection is established.

The following retrieves a file from the Reserve Bank of Australia and maps 
the elements that are used: data, dates, identifiers, and series names. 
\begin{Scode}{results=verbatim}
  library("TSxls")  
  rba <- TSconnect("xls",
          dbname="http://www.rba.gov.au/statistics/tables/xls/d03hist.xls",
          map=list(ids  =list(i=11,     j="B:Q"), 
	           data =list(i=12:627, j="B:Q"), 
	           dates=list(i=12:627, j="A"),
                   names=list(i=4:7,    j="B:Q"), 
		   description = NULL,
		   tsrepresentation = function(data,dates){
		       ts(data,start=c(1959,7), frequency=12)}))
\end{Scode}

This also illustrates how \code{tsrepresentation} can be specified as an 
arbitrary function to set the returned time series object representation.

Beware that data is read into \pkg{R} when the connection is established, so
changes in the spreadsheet will not be visible in \pkg{R} until a new connection
is established.

\begin{Scode}{results=verbatim,fig=TRUE}
  x <- TSget("DMACN", rba)
  require("tfplot")
  tfplot(x)
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE,height=8}
  x <- TSget(c("DMAM1N", "DMAM3N"), rba)
  tfplot(x)
  TSdescription(x) 
\end{Scode}

\code{tfplot} treats each series in the first argument as a panel to be plotted.
It is possible to specify the number of graphs on each page of the output device
with the argument \code{graphs.per.page}. As previously illustrated, it is 
also possible to specify that a subset of the series should be selected.
(Also, as already illustrated above, the function \code{plot} displays the series 
somewhat differently than \code{tfplot}, and possibly differently depending on
the objects time series representation.)

\code{tfplot} takes additional time series objects as arguments. Series in the
first argument are plotted in separate panels. Series in subsequent time series
objects will be plotted respectively on the same panels as the first, 
so the number of series in each object must be the same.
\begin{Scode}{results=verbatim,fig=TRUE,height=8}
  tfplot(TSget(c("DMAM1S", "DMAM3S", "DMABMS"), rba),
         TSget(c("DMAM1N", "DMAM3N", "DMABMN"), rba),
    ylab=c("DMAM1", "DMAM3", "DMABM"),
    Title="Australian Monetary Aggregates")
\end{Scode}
%%
\subsection{TSzip}
%%
\pkg{TSzip} provides methods for the \pkg{TSdbi} interface, allowing the 
use of zipped files that can be read by \code{read.table} as if each file is a
database series (or group of series such as high, low, open, close, for a
stock). The \code{dbname} is a directory or \code{url}. 
\pkg{TSzip} does not support writing data to the database. 

The following retrieves zipped files 
from \url{http://pitrading.com/free\_market\_data.htm} which 
provides some end of day data free of charge. (Disclaimer: This site is 
used as an example. Other than using this free data, I have no association 
with the company.) 
\begin{Scode}{results=verbatim,fig=TRUE,height=8}
  library("TSzip")  
  pitr <- TSconnect("zip", dbname="http://pitrading.com/free_eod_data")
  z <- TSget("INDU", pitr)
  tfplot(z, series=c(1,4))
\end{Scode}

The following illustrates returning an \code{xts} \citep{xts} time series object.
\begin{Scode}{results=verbatim,fig=TRUE,height=8}
  z <- TSget(c("EURUSD", "GBPUSD"), pitr, quote=c("Open","Close"),
         TSrepresentation=xts)
  tfplot(z,
         Title="EURUSD and GBPUSD open and closing values from pitrading", 
         start="1995-01-01",
         par=list(omi=c(0.1,0.3,0.1,0.1),mar=c(2.1,3.1,1.0,0.1)))
\end{Scode}

The default appearance of graphs can be changed (improved) by adjusting graphics 
device margins \code{omi} and \code{mar}. (They are set by the vector in 
order: bottom, left, top, right.) The default behaviour is a compromise that
usually works reasonally well for both screen and printed output.
It is often useful to adjust these when generating \emph{pdf}
files for publication.
%%
%%
\section{SQL Time Series Databases}
\label{sec:SQL}
%%
This section gives several simple examples of putting series on and reading them
from a database. (If a large number of series are to be loaded into a database,
one would typically do this with a batch process using the database program's
utilities for loading data.)
The examples in this section will use \pkg{TSMySQL} but, other than the initial
connection, access will be similar for other SQL \pkg{TS*} packages. The syntax
for connecting with other packages, and other options for connecting with 
\pkg{TSMySQL}, are provided in Appendix ``A''.

The packages \pkg{TSPostgreSQL}, \pkg{TSMySQL}, 
\pkg{TSSQLite}, and \pkg{TSodbc}
use underlying packages \pkg{RPostgreSQL} \citep{RPostgreSQL}, 
\pkg{RMySQL} \citep{RMySQL}, \pkg{RSQLite} \citep{RSQLite}, and
\pkg{RODBC} \citep{RODBC}.
The \pkg{TS*} packages provide access to an SQL database with an underlying 
table structure that is set up to store time series data. 

The next lines of code do some preliminary setup of the database. This uses the
underlying database connection (\code{dbConnect}) rather than \code{TSconnect},
because \code{TSconnect} will not recognize the database until it has been
setup.


WARNING: running this will overwrite the ``test'' database on your server.

\begin{Scode}
 library("TSMySQL")
 con <- dbConnect("MySQL", dbname="test") 
 source(system.file("TSsql/CreateTables.TSsql", package = "TSdbi"))
 dbDisconnect(con)
\end{Scode}
%%
%%
\subsection{Writing to SQL Databases}
%%
This subsection illustrates writing some simple artifical data to a database,
and reading it back.
This part of the vignette is generated using \pkg{TSMySQL}, but other backend SQL
servers work in a similar way. See Appendix ``A'' for details of establishing
other SQL database connections.


The first thing to do is to establish a \code{TSdbi} connection to the database:

\begin{Scode}{results=hide}
 library("TSMySQL")
 con <- TSconnect("MySQL", dbname="test") 
\end{Scode}

\code{TSconnect} uses \code{dbConnect} from the \pkg{DBI} package, but checks that the
database has expected tables, and checks for additional features. (It cannot
be used before the tables are created, as was done above.)

The follow illustrates the use of the \pkg{TSdbi} interface, which is 
common to all extension packages.

This puts a series called \code{vec}  on the database and then reads is back
 
\begin{Scode}
 z <- ts(rnorm(10), start=c(1990,1), frequency=1)
 seriesNames(z) <- "vec"
 if(TSexists("vec", con)) TSdelete("vec", con) 
 TSput( z, con)
 z <- TSget("vec", con)
\end{Scode}

Note that the series name(s) and not the \proglang{R} variable name 
(in this case, \code{vec} not \code{z}) are used on the database. 
If the retrieved series is printed it is seen to be a ``ts'' time series with some extra
attributes.

\code{TSput} fails if the series already exists on the \code{con}, 
so the above example checks and deletes the series if it already exists. 
\code{TSreplace} does not fail if the series does
not yet exist, so examples below use it instead. 
\code{TSput}, \code{TSdelete}, \code{TSreplace}, and  \code{TSexists} all
return logical values \code{TRUE} or \code{FALSE}.

Several plots below show
original data and the data retrieved after it is written to the database. 
In the plot below, one is
added to the original data so that both lines are visible.

The \proglang{R} variable can contain multiple series of the same frequency. 
They are stored separately on the database.

\begin{Scode}{results=verbatim,fig=TRUE,height=8}
 z <- ts(matrix(rnorm(200),100,2), start=c(1995,1), frequency=12)
  seriesNames(z) <- c("mat2c1", "mat2c2")
 TSreplace(z, con)
 tfplot(z+1, TSget(c("mat2c1","mat2c2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}
 
The following extract information about the series from the database, although
not much information has been added for these examples. 
\begin{Scode}{results=verbatim}
 TSmeta("mat2c1", con)
 TSmeta("vec", con)
 TSdates("vec", con)
 TSdescription("vec", con)
 TSdoc("vec", con)
 TSlabel("vec", con)
\end{Scode}

Data documentation can be in three forms. A description specified by 
\code{TSdescription},
longer documentation specified by \code{TSdoc}, or a short label, typically
useful on a graph, specified by \code{TSlabel}. 
These can be added to the time
series object, in which case they will be written to the database when
\code{TSput} or \code{TSreplace} is used to put the series on the database. 
Alternatively, they
can be specified as arguments to \code{TSput} or \code{TSreplace}.
The description or documentation will be retrieved as part of the series object
with \code{TSget} only if this is specified with the logical arguments
\code{TSdescription} and \code{TSdoc}. They can also be retrieved directly from the
database with the functions \code{TSdescription} and \code{TSdoc}.

\begin{Scode}{results=verbatim}
 z <- ts(matrix(rnorm(10),10,1), start=c(1990,1), frequency=1)
 TSreplace(z, serIDs="Series1", con) 
 zz <- TSget("Series1", con)
 TSreplace(z, serIDs="Series1", con, 
     TSdescription="short rnorm series", 
     TSdoc="Series created as an example in the vignette.")
 zz <- TSget("Series1", con, TSdescription=TRUE, TSdoc=TRUE)
 start(zz)
 end(zz)
 TSdescription(zz)
 TSdoc(zz)

 TSdescription("Series1", con)
 TSdoc("Series1", con)
\end{Scode}

The following examples use dates and times which are not handled by \code{ts},
so the \pkg{zoo} time representation is used. It is necessary to specify the
table where the data should be stored in cases where it is difficult to
determine the periodicity of the data. See Appendix ``B'' for details of the
specific tables.

\begin{Scode}{results=verbatim,fig=TRUE,height=8}
 require("zoo") 

 z <- zoo(matrix(rnorm(200),100,2), as.Date("1990-01-01") + 0:99)
  seriesNames(z) <- c("zooc1", "zooc2")
 TSreplace(z, con, Table="D")
 tfplot(z+1, TSget(c("zooc1","zooc2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))
  
\end{Scode}

\begin{Scode}{results=verbatim}
 z <- zoo(matrix(rnorm(200),100,2), as.Date("1990-01-01") + 0:99 * 7)
  seriesNames(z) <- c("zooWc1", "zooWc2")
 TSreplace(z, con, Table="W")
\end{Scode}

\begin{Scode}{results=hide}
  dbDisconnect(con)
  detach(package:TSMySQL)
  detach(package:RMySQL)
\end{Scode}
%%
\section{More Examples}
\label{sec:MoreExamples}
%%
\subsection{Examples Using SQL Databases}
\label{sec:SQLexamples}
%%
This section illustrates fetching data from the web  and loading it into the
database. This would be a very slow way to load a database, but provides
examples of different kinds of time series data. The fetching is done with 
\pkg{TShistQuote}.
Fetching data can fail due to lack of an Internet connection or delays, which
will cause the generation of this vignette to fail. 

This part of the vignette is generated using \pkg{TSPostgreSQL}, but other backend SQL
servers work in a similar way. See Appendix ``A'' for details of establishing
other SQL database connections.

First establish a connection to the database where data will be saved:
\begin{Scode}
  require("TSPostgreSQL")
  host    <- Sys.getenv("POSTGRES_HOST")
  con <-  TSconnect("PostgreSQL", dbname="test", host=host) 
\end{Scode}

Now connect to the web server and fetch data:

\begin{Scode}{results=verbatim}
  require("TShistQuote")
  yahoo <- TSconnect("histQuote", dbname="yahoo") 
  x <- TSget("^gspc", quote = "Close", con=yahoo)
\end{Scode}

Then write the data to the local server, specifying table B for business day 
data (using TSreplace in case the series
is already there from running this example previously):

\begin{Scode}{results=verbatim}
   TSreplace(x,  serIDs="gspc", Table="B", con=con)
\end{Scode}

and check the saved version:

\begin{Scode}{results=verbatim,fig=TRUE}
  TSrefperiod(TSget(serIDs="gspc", con=con)) 
  TSdescription("gspc", con=con) 
  TSdoc("gspc", con=con)
  tfplot(TSget(serIDs="gspc", con=con))
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE,height=8}
   x <- TSget("ibm", quote = c("Close", "Vol"), con=yahoo)
   TSreplace(x, serIDs=c("ibm.Cl", "ibm.Vol"),  con=con, Table="B",
              TSdescription.=c("IBM Close","IBM  Volume"),
	      TSdoc.= paste(c(
	         "IBM  Close   retrieved on ",
		 "IBM  Volume retrieved  on "), Sys.Date()))

   z <- TSget(serIDs=c("ibm.Cl", "ibm.Vol"), 
             TSdescription=TRUE, TSdoc=TRUE, con=con)
   TSdescription(z)
   TSdoc(z)
   tfplot(z, xlab = TSdoc(z), Title = TSdescription(z))
   tfplot(z, Title="IBM", start="2007-01-01")
\end{Scode}
%%
%% this is causing problems because around July 2012 Yahoo began frequently
%% having dupicate data on the final day (seems to be partial data for the 
%% next day?), which causes zoo the complain. Hopefully Yahoo bug will be fixed.
%%\begin{Scode}{results=verbatim,fig=TRUE,height=8}
%%  x <- TSget(c("^ftse","^gspc"), con)
%%  plot(x)
%%\end{Scode}
%%
%%\begin{Scode}{results=verbatim,fig=TRUE,height=8}
%%  tfplot(x)
%%  TSdescription(x) 
%%\end{Scode}
%%
%%\begin{Scode}{results=verbatim,fig=TRUE}
%%  x <- TSget("ibm", con, quote = c("Close", "Vol"))
%%  tfplot(x)
%%\end{Scode}
%%
%%\begin{Scode}{results=verbatim,fig=TRUE,height=8}
%%  tfplot(x, xlab = TSdescription(x))
%%\end{Scode}
%%
%%\begin{Scode}{results=verbatim,fig=TRUE}
%%  tfplot(x, Title="IBM", start="2007-01-01")
%%\end{Scode}
%%
%%\begin{Scode}{results=verbatim,fig=TRUE}
%%  tfplot(x, Title=TSdoc(x), xlab = TSlabel(x), start="2007-01-01")
%%\end{Scode}


Oanda has maximum of 500 days, so the start date is specified here so as to
not exceed that.

\begin{Scode}{results=verbatim}
   Oanda <- TSconnect("histQuote", dbname="oanda") 
   x <- TSget("EUR/USD", start=Sys.Date() - 495, con=Oanda)
   TSreplace(x, serIDs="EUR/USD", Table="D", con=con)
\end{Scode}

Then check the saved version:

\begin{Scode}{results=verbatim,fig=TRUE}
   z <- TSget(serIDs="EUR/USD",TSlabel=TRUE, 
                  TSdescription=TRUE,  con=con)
   tfplot(z, Title = TSdescription(z), ylab=TSlabel(z),
            start="2007-03-01")
\end{Scode}

\begin{Scode}{results=hide}
  dbDisconnect(con)
  dbDisconnect(yahoo)
  dbDisconnect(Oanda)
  detach(package:TSPostgreSQL)
  detach(package:RPostgreSQL)
\end{Scode}
%%
%%
\subsection{``Inhouse'' Database Examples}
\label{sec:etsExamples}
%%
These examples use a database which has been called ``ets''. It has already been
populated with some series from various sources, so
the examples illustrate how a large ``inhouse'' database might be used. 
Typically a large database would be installed using
database scripts directly rather than from \proglang{R} with \code{TSput} or
\code{TSreplace}. 

The following uses \pkg{TSMySQL} but, other than the initial connection,
everything should remain the same if another database is used. (See Appendix A
regarding the details of other connections.)

First, establish a connection to the database, and make it the default.
\begin{Scode}{results=verbatim,fig=FALSE}
  library("TSMySQL")
  ets <-  TSconnect("MySQL", dbname="ets") 
  options(TSconnection=ets)
\end{Scode}

Often one needs to check if data is available or has been updated.
This defines a list of series ids, with more explanatory names, 
and checks availability:
\begin{Scode}{results=verbatim,fig=FALSE}
  EXCH.IDs <- matrix(c(
 	"M.SDR.CCUSMA02.ST",	 "SDR/USD exchange rate",
 	"M.CAN.CCUSMA02.ST",	 "CAN/USD exchange rate",
 	"M.MEX.CCUSMA02.ST",	 "MEX/USD exchange rate",
 	"M.JPN.CCUSMA02.ST",	 "JPN/USD exchange rate",
 	"M.EMU.CCUSMA02.ST",	 "Euro/USD exchange rate",
 	"M.OTO.CCUSMA02.ST",	 "OECD /USD exchange rate",
 	"M.G7M.CCUSMA02.ST",	 "G7   /USD exchange rate",
 	"M.E15.CCUSMA02.ST",	 "Euro 15. /USD exchange rate"
	), 2, 8)

  TSdates(EXCH.IDs[1,])
\end{Scode}

(The available data in this test data set is fairly old.)

The following examples illustrate using metadata in the graph.
\begin{Scode}{results=verbatim,fig=TRUE}
  z <- TSget("V122646", TSdescription=TRUE, TSsource=TRUE, TSdoc=TRUE,
              TSlabel=TRUE )
  tfplot(z, Title=strsplit(TSdescription(z), ","))
\end{Scode}

Some metadata fields in my example database are empty. If they were available,
this step would not be necssary. The missing meta data can be put into 
the returned object by:
\begin{Scode}{results=verbatim}
  TSsource(z) <- "Bank of Canada"
  TSlabel(z) <- "Short-Term Business Credit"
\end{Scode}

With this, more of the meta data can be indicated on the graph:
\begin{Scode}{results=verbatim,fig=TRUE}
  tfplot(ytoypc(z), ylab="Year-over-Year Growth",
    Title=TSlabel(z),
    source=paste(TSseriesIDs(z), "from", TSsource(z)),
    lastObs=TRUE, 
    footnote=TSdescription(z))
\end{Scode}

%%\begin{Scode}{results=verbatim,fig=TRUE}
%%  z <- TSget(c("DSP500","SDSP500"), TSdescription=TRUE)
%%  tfplot(z, xlab=TSdescription(z))
%%\end{Scode}
  
\begin{Scode}
  dbDisconnect(ets)
  options(TSconnection=NULL)
\end{Scode}

\begin{Scode}
  detach(package:TSMySQL)
  detach(package:RMySQL)
\end{Scode}
%%
%%\section{Fancy Graphs with data from several sources}
%%\label{sec:Fancy}
%%
%% do this with Can and US using cansim and FRED
%%\begin{Scode}{results=verbatim,fig=TRUE}
%%  ETSgdp    <- annualizedGrowth(aggregate(TSget("V1992067", cansim),
%%                  nfrequency=4,FUN=mean), lag=4, names="GDP Y/Y Growth")
%%  tfplot(ETSgdp)
%%\end{Scode}
%%
%%
%%
\section{Comparing Time Series Databases}
\label{sec:Comparing}
%%
The purpose of package \pkg{TScompare} is to compare pairs of series on two database.
These series might have the same name, but for generality the main function, 
\code{TScompare}, is set up to use name pairs. The pairs to compare are 
indicated by a matrix of strings with two columns. (It would also be 
possible to compare pairs on the same database, which might make sense if
the names are different.) 

The connections are established using other \pkg{TSdbi} packages such as \pkg{TSMySQL}, 
\pkg{TSPostgreSQL}, etc. It will be necessary to establish two database connections, 
so it will also be necessary to load the database specific packages. 
Examples in this vignette use \pkg{TShistQuote},  \pkg{TSMySQL} 
and \pkg{TSSQLite}. 

\begin{Scode}
library("TScompare")  
library("TShistQuote")  
library("TSMySQL")  
library("TSSQLite")  
\end{Scode}

First setup database tables that are used by TSdbi using a \code{dbConnect}
connection, after which a \code{TSconnect} connection can be used
(This is re-done to insure the database are empty): 
\begin{Scode}{results=hide}
 con <- dbConnect("MySQL", dbname="test") 
 source(system.file("TSsql/CreateTables.TSsql", package = "TSdbi"))
 dbDisconnect(con)

 con <- dbConnect("SQLite", dbname="test") 
 source(system.file("TSsql/CreateTables.TSsql", package = "TSdbi"))
 dbDisconnect(con)
\end{Scode}

Now TS connections to the databases are established.
\begin{Scode}{results=hide}
  con1 <- TSconnect("MySQL", dbname="test")
  con2 <- TSconnect("SQLite", dbname="test") 
\end{Scode} 

Next a connection to yahoo is used to get some series and write them to the 
local test database. (See the vignette for \pkg{TShistQuote} for more examples 
of reading series from the web.) \code{TSreplace} is used because \code{TSput} 
will fail if the series already exisits.

\begin{Scode}{results=verbatim}
  yahoo <- TSconnect("histQuote", dbname="yahoo") 
  x <- TSget("^ftse", yahoo)
  TSreplace(x, serIDs="ftse", Table="B", con=con1)
  TSreplace(x, serIDs="ftse", Table="B", con=con2)

  x <- TSget("^gspc", yahoo)
  TSreplace(x,  serIDs="gspc", Table="B", con=con1)
  TSreplace(x,  serIDs="gspc", Table="B", con=con2)

  x <- TSget("ibm", con=yahoo, quote = c("Close", "Vol"))
  TSreplace(x, serIDs=c("ibmClose", "ibmVol"), Table="B", con=con1)
  TSreplace(x, serIDs=c("ibmC",     "ibmV"),   Table="B", con=con2)
\end{Scode}

Now to do a comparison:
\begin{Scode}{results=verbatim}
  ids <- AllIds(con1)
  ids
\end{Scode}

If the second database has the same names then ids can be made into a 
matrix with identical columns. 

\begin{Scode}{results=verbatim}
  ids <- cbind(ids, ids)

  eq   <- TScompare(ids, con1, con2, na.rm=FALSE)
  summary(eq)

  eqrm <- TScompare(ids, con1, con2, na.rm=TRUE)
  summary(eqrm)
\end{Scode}

Since names are not identical the above indicates discrepancies, which 
are resolves by indicating the corresponding name pairs:
\begin{Scode}{results=verbatim}
  ids <- matrix(c("ftse","gspc","ibmClose", "ibmVol",
                  "ftse","gspc","ibmC", "ibmV"),4,2)

  ids
  eq   <- TScompare(ids, con1, con2, na.rm=FALSE)
  summary(eq)

  eqrm <- TScompare(ids, con1, con2, na.rm=TRUE)
  summary(eqrm)
\end{Scode}

While it may not be necessary to \code{detach} packages, the following prevents
warnings later about objects being masked:
\begin{Scode}
  detach(package:TSMySQL)
  detach(package:RMySQL)
  detach(package:TSSQLite)
  detach(package:RSQLite)
\end{Scode}
%%
%%
%%
\section{Vintages of Realtime Data}
\label{sec:Vintages}
%%
Data vintages, or ``realtime data'' are snapshots of data that was available
at different points in time. The most obvious feature of earlier snapshots is
that the series end earlier. However, the reason for retaining vintages is that
data is often revised, so, for some observations,
earlier vintages have different data. Typically most revisions happen for the
most recent periods, but this is often the data of most interest for forcasting
and policy decisions. Thus, the revision records are valuable for understanding the
implications of differences between early and revised releases of the data.
A simple mechanism for accessing vintages of data is available in several
\pkg{TS*} packages. This is illustrated here with an SQL database that has been
set up with vintage support.

First establish a connection to th database and get
a vector of the available vintages:
\begin{Scode}{results=verbatim,fig=FALSE}
require("TSMySQL") 
require("tfplot") 
ets <- TSconnect("MySQL",dbname="etsv") 
v  <- TSvintages(ets)
\end{Scode}

The following checks if a certain variable (Consumer Credit -- V122707) is
available in the different vintages. (V numbers replaced B numbers circa 2003, 
so the V numbers do not exist in older vintages. This could be supported by
implementing aliases, but that has not been done here.)
\begin{Scode}{results=verbatim,fig=FALSE}
ve <- TSexists("V122707", vintage=v, con=ets)
\end{Scode}

%A temporary problem with the db loading of some vintages is fixed by
\begin{Scode}{results=hide,fig=FALSE}
ve[224:length(ve)] <- FALSE 
\end{Scode}

The vintages can them be retrieved and plotted by
\begin{Scode}{results=verbatim,fig=TRUE}
CC <- TSget(serIDs="V122707", con=ets, vintage=v[ve])

tfOnePlot(ytoypc(CC), start=c(2000,1), 
   ylab="Consumer Credit (V122707) y/y Growth",
   Title=paste("Vintages", v[ve][1], "to",  v[ve][189]),
   lastObs=TRUE, source="Source: Bank of Canada")
\end{Scode}

With package \pkg{TSfame} vintages are supported if the vintages are 
stored in files
with names like ``etsmfacansim\_20110513.db''. Then the vintages can be accessed 
as follows:

\begin{Scode}{eval=FALSE}
  dbs <- paste("ets /path/to/etsmfacansim_", c(
             "20110513.db", "20060526.db", "20110520.db"), sep="")
  names(dbs) <- c("2011-05-13", "2006-05-26", "2011-05-20")
	     
  conetsV <-TSconnect("fame", dbname=dbs, "read", current="2011-05-13")

  z <- TSget("V122646", con=conetsV, vintage=c("2011-05-13", "2006-05-26"))
  dbDisconnect(conetsV)
\end{Scode}

(The above example should work, but beware that I am no longer testing it
because I no longer have Fame access.)

The package \pkg{googleVis} can be used to produce a plot that is very useful
for examining vintage more closely, and finding outliers and other 
data problems. The names are used in the legend of this next plot, 
so the series names are specified in the argument to \code{ytoypc}. 
(Otherwise they get reset to indicate the year-to-year calculation, which
makes the legend messy to read.)

\begin{Scode}{eval=FALSE,fig=FALSE}
require("googleVis") 
tfVisPlot(ytoypc(CC, names=seriesNames(CC)), start=c(2006,1),
    options=list(title="Vintages of Consumer Credit (V122707) y/y Growth"))
\end{Scode}

This will produce a graph in your web browser. It is not reproduced here.
(And beware that it may not be very fast.)
Pointing your mouse at the legend of this plot will highlight the corresponding
vintage, and
pointing at the graph will give information about the source of a data point.
%%
%%
%%
\section{Appendix A: Connection Specific Details}
\label{appdx:A}
%%
This section provides details of the different connections which are specific to
individual packages and backend databases. In order to make the examples
complete, for the SQL versions, test databases are first created with 
the tables expected by the 
\pkg{TS*} packages. Note that this is done with a \code{dbConnect} connection
rather than a \code{TSconnect} connection, because \code{TSconnect} expects
the tables to exist already.

WARNING: running these example will overwrite tables in the
``test'' database on the server.


The database setup might typically be done by an administrator, rather than 
by an end user. Here it is done using a small script \code{CreateTables.TSsql} 
distributed with the \pkg{TSdbi} package. 
A more detailed description of the
instructions for building the database tables is given in the vignette 
for the \pkg{TSdbi} package. Those instruction show how to build the database
using database utilites rather than \proglang{R}, which might be the way a
system administrator would build the database.

In many cases there are two or more ways to pass information like the 
\code{username}, \code{password}, and \code{server} or \code{host}. One
mechanism is that this information is specified in a configuration file in the
user's home directory. The database driver then reads this information and it is
not part of the user's \proglang{R} session. 
(Often this is considered the most secure way.) 
Another way is that environment variables are set, and the database driver uses
these. Again, this is not part of the user's R session.
Still another way is that the user passes this information in the call to
\code{TSconnect} in their \proglang{R} session. In this case the character strings are
visible in the R session, and possibly recorded in the user's R scripts, thus
this is typically not considered to be very secure. A modification, which is only
a little bit better, is for the user's \proglang{R} scripts to read the information from
environment variables using, for example:  
\begin{Scode}
   user <- Sys.getenv("MYSQL_USER")
\end{Scode}
   
%%
\subsection{TSMySQL Connection Details}
%%
The MySQL  user, password, and hostname should be set in MySQL client
configuration file (.my.cnf) in the user's home directory before starting R. 
Alternatively, this information can be set with
environment variables  MYSQL\_USER, MYSQL\_PASSWD and MYSQL\_HOST.
(An environment variable MYSQL\_DATABASE can also be set, but ``test'' is
specified below.) Below the configuration file is used.

The next small section of code uses \code{dbConnect} to set up database 
tables that expected by \code{TSconnect}. 
%%
\begin{Scode}{results=hide}
 library("TSMySQL")
 con <-  dbConnect("MySQL", dbname="test") 
 source(system.file("TSsql/CreateTables.TSsql", package = "TSdbi"))
 dbDisconnect(con)
\end{Scode}

Now a TSdbi connection to the database is established.
\begin{Scode}{results=hide}
  con  <-  TSconnect("MySQL", dbname="test")
\end{Scode} 

The alternative to pass the user/password information in the arguments to
the connection function would be:
\begin{Scode}{results=hide,eval=FALSE}
con <-  TSconnect("MySQL", dbname="test", username=user, password=passwd, host=host)
\end{Scode} 

This is may be cumbersome to change, and is generally considered to be less
secure.

While it may not be necessary to \code{detach} packages, the following prevents
warnings later about objects being masked:
\begin{Scode}
  detach(package:TSMySQL)
  detach(package:RMySQL)
\end{Scode}
%%
%%
\subsection{TSPostgreSQL Connection Details}
%%
The PostgreSQL  user, and password, can be set in PostgreSQL 
configuration file (.pgpass in Linux) in the user's home directory before 
starting R. 
The Postgress documentation suggests that it should be
possible to get the host from the .pgpass file too, but I have not been able
to make that work. The PostgreSQL alternative to the configuration file
is to use environment variables PGDATABASE, PGHOST, PGPORT, and PGUSER.
This package supports another alternatively to set this information 
with environment variables  POSTGRES\_USER, POSTGRES\_PASSWD 
and POSTGRES\_HOST, which are read in the R code.
(An environment variable POSTGRES\_DATABASE can also be set, but ``test'' is
specified below.)  Below, the environment variable POSTGRES\_HOST is used to
determine the host server, but the .pgpass file is used for the user and 
password information.

\begin{Scode}
   host    <- Sys.getenv("POSTGRES_HOST")
\end{Scode}

The next small section of code uses \code{dbConnect} to set up database 
tables that expected by \code{TSconnect}. 
%%
\begin{Scode}{results=hide}
  library("TSPostgreSQL")
  con  <- dbConnect("PostgreSQL", dbname="test", host=host)
  source(system.file("TSsql/CreateTables.TSsql", package = "TSdbi"))
  dbDisconnect(con)
\end{Scode}

Now a TSdbi connection to the database is established.
\begin{Scode}{results=hide}
  con  <-  TSconnect("PostgreSQL", dbname="test", host=host)
\end{Scode} 

Another alternative is to pass the user/password information in the arguments to
the connection function:
\begin{Scode}{results=hide,eval=FALSE}
  con <-  TSconnect("PostgreSQL", dbname="test", user=user, password=passwd, host=host)
\end{Scode} 

This is may be cumbersome to change, and is generally considered to be less
secure.

While it may not be necessary to \code{detach} packages, the following prevents
warnings later about objects being masked:
\begin{Scode}
  detach(package:TSPostgreSQL)
  detach(package:RPostgreSQL)
\end{Scode}
%%
%%
%%
\subsection{TSSQLite Connection Details}
%%
In SQLite  there does not seem to be any need to set user or password 
information, and examples here all use the localhost.

Now setup database tables that are used by TSdbi using a \code{dbConnect}
connection, after which a \code{TSconnect} connection can be used: 
\begin{Scode}{results=hide}
 library("TSSQLite")
 con <- dbConnect("SQLite", dbname="test") 
 source(system.file("TSsql/CreateTables.TSsql", package = "TSdbi"))
 dbDisconnect(con)
\end{Scode}

Now a TSdbi connection to the database is established.
\begin{Scode}{results=hide}
  con  <-  TSconnect("SQLite", dbname="test")
\end{Scode} 

While it may not be necessary to \code{detach} packages, the following prevents
warnings later about objects being masked:
\begin{Scode}
  detach(package:TSSQLite)
  detach(package:RSQLite)
\end{Scode}
%%
%%
%%
\subsection{TSodbc Connection Details}
%%
The ODBC  user, password, hostname, etc, should be set in ODBC client
configuration file in the user's home directory (.odbc.ini in Linux) 
before starting R. An example of this file is provided below. It will also
be necessary to have the appropriate driver installed on the system
(Postgresql in the example below).
Alternatively, it should be possible to set this information with
environment variables  ODBC\_USER, ODBC\_PASSWD and ODBC\_DATABASE. 
However, the 
variable ODBC\_HOST does not seem to work for passing the ODBC connection, 
so a properly setup ODBC configuration file is needed.  Because of this, the
environment variable mechanism is not currently supported in \pkg{TSodbc}
and the user, passwd, and host settings should be done in the configuration file.

Now setup database tables that are used by TSdbi using a \code{odbcConnect}
connection, after which a \code{TSconnect} connection can be used: 
%%
\begin{Scode}{results=hide}
library("TSodbc")
con <-  odbcConnect(dsn="test") 
if(con == -1) stop("error establishing ODBC connection.") 
source(system.file("TSsql/CreateTables.TSsql", package = "TSdbi"))
odbcClose(channel=con)
\end{Scode}

Now a TSdbi connection to the database is established.
\begin{Scode}{results=hide}
  con  <-  TSconnect("ODBC", dbname="test")
\end{Scode} 

Another alternative is to pass the user/password information in the arguments to
the connection function:
\begin{Scode}{results=hide,eval=FALSE}
con  <-  TSconnect("ODBC", dbname="test", uid=user, pwd=passwd)
\end{Scode} 

This is may be cumbersome to change, and is generally considered to be less
secure.


While it may not be necessary to \code{detach} packages, the following prevents
warnings later about objects being masked:
\begin{Scode}
  detach(package:TSodbc)
  detach(package:RODBC)
\end{Scode}
%%
%%
\subsubsection{Example ODBC configuration file}
%%
Following is an example ODBC configuration file I use in Linux (so the file is
in my home directory and called  ``.odbc.ini'') to connect to a remote
PostgreSQL server:

\begin{verbatim}
[test]

Description             = test DB (Postgresql)
Driver                  = Postgresql
Trace                   = No
TraceFile               = /tmp/test_odbc.log
Database                = test
Servername              = some.host
UserName                = paul
Password                = mySecret
Port                    = 5432
Protocol                = 6.4
ReadOnly                = No
RowVersioning           = No
ShowSystemTables        = No
ShowOidColumn           = No
FakeOidIndex            = No
ConnSettings            =


[ets]

Description             = ets DB (Postgresql)
Driver                  = Postgresql
Trace                   = No
TraceFile               = /tmp/test_odbc.log
Database                = ets
Servername              = some.host
UserName                = paul
Password                = mySecret
Port                    = 5432
Protocol                = 6.4
ReadOnly                = No
RowVersioning           = No
ShowSystemTables        = No
ShowOidColumn           = No
FakeOidIndex            = No
ConnSettings            =
\end{verbatim}

The above depends on the driver tag ``Postgresql'' being defined in the
file /etc/odbcinst.ini, to give the actual driver file location. That file might
have something like

\begin{verbatim}
[PostgreSQL]
Description		= PostgreSQL ODBC driver (Unicode version)
Driver          = /usr/lib/x86_64-linux-gnu/odbc/psqlodbcw.so
Setup           = /usr/lib/x86_64-linux-gnu/odbc/libodbcpsqlS.so
Debug		= 0
CommLog		= 1
UsageCount	= 1
\end{verbatim}

%%
%%
\subsection{TSOracle Connection Details}
%%

This package is available on R-forge, but is not being tested, because I do not
currently have a server to test it. 
The code in this section of the vignette is not being run.
Please contact the package maintainer (Paul Gilbert) if 
you have an Oracle server and are willing to test the package.

The Oracle  user, password, and hostname should be set in Oracle client
configuration file (tnsnames.ora) before starting R. 

The next small section of code uses \code{dbConnect} to set up database 
tables that expected by \code{TSconnect}. 
%%
\begin{Scode}{eval=FALSE}
 library("TSOracle")
 con  <- dbConnect("Oracle", dbname="test") 
 source(system.file("TSsql/CreateTables.TSsql", package = "TSdbi"))
 dbDisconnect(con)
\end{Scode}


Now a TSdbi connection to the database is established.
\begin{Scode}{eval=FALSE}
  con  <-  TSconnect("Oracle", dbname="test")
\end{Scode} 

While it may not be necessary to \code{detach} packages, the following prevents
warnings later about objects being masked:
\begin{Scode}{eval=FALSE}
  detach(package:TSOracle)
  detach(package:ROracle)
\end{Scode}
%%
%%
%%
\subsection{TSfame Connection Details}
%%
I no longer have access to Fame so package \pkg{TSfame} is no longer being
extensively tested.  
The code in this section of the vignette is not being run.
Please contact the package maintainer (Paul Gilbert) if 
you have Fame and are willing to test the package.

Beware that the package \pkg{fame} may be installed but not functional 
because the Fame HLI code is not available. 
A warning will be issued in this case.

Two variants of the Fame connect are available. The first requires a Fame
database available on the local system:
\begin{Scode}{eval=FALSE}
  con <- TSconnect("fame", dbname="testFame.db") 
\end{Scode}

The second requires a Fame server:
\begin{Scode}{eval=FALSE}
  con <- TSconnect("fame", dbname="ets /path/to/etsmfacansim.db", "read") 
\end{Scode}
where the characters before the space in the dbname string indicate the network
name of the server, and the path after the string indicates where the server
should find the database.

While it may not be necessary to \code{detach} packages, the following prevents
warnings later about objects being masked:
\begin{Scode}{eval=FALSE}
  detach(package:TSfame)
  detach(package:fame)
\end{Scode}
%%
%%
%%
\subsection{TSpadi Connection Details}
%%

\pkg{TSpadi} has been largely replaced by other TS* packages and is no longer
extensively tested.
The code in this section of the vignette is not being run.

TSpadi is a \pkg{TSdbi} style interface to a server which 
extracts data from a backend database. At the Bank of Canada,
Fame was the backend database engine. For simplified testing, the backend is
a simple set of files, each containing a time series, in a directory which the
server can read.

The R client communicates with the server using
an RPC based protocol which has been called ``padi'', so only the server 
requires the Fame programs and licences. 

\pkg{TSpadi} does not support writing data to a database, so examples below are
restricted to an already available database. Alternate approaches for interfacing
to Fame are the R packages \pkg{fame} and \pkg{TSfame}. The later is just a 
wrapper for the former, to give it a \pkg{TSdbi} style interface. Both allow
writing to the Fame database, but both also require the Fame HLI programs and
licences for the client R machine.

The username and password are not supported, but allowed for compatability with
other packages. The host server should be specified. The dbname may or may not 
be used, depending on how the server is configured,
The user, password, and host can be specified in a single line file (.padi.cfg)
in the user's home directory. The line should be  ``user password host''. The
R code reads this file. Alternatively, the fields can be passed directly
to \code{TSconnect}. 

\begin{Scode}{eval=FALSE}
  library("TSpadi") 
  # pass user/passwd/host in .padi.cfg   
  con <- TSconnect("padi", dbname="ets") 
\end{Scode}

Another alternative is
\begin{Scode}{eval=FALSE}
  con <- TSconnect("padi", dbname="ets", username=user, 
                   password=passwd, host=host)
\end{Scode}

While \pkg{TSpadi} does not require Fame on the R clients, there is 
additional work to 
set up the padi server and configure it to load databases. Please check 
additional comments in the last section ``TS PADI Server'' before deciding
about using the \pkg{TSpadi} interface (and you may want to contact me, 
Paul Gilbert). I have actively use this interface until recently, 
but now only test a simple version of a server. 
One of the main purposes 
of \pkg{TSpadi} is to standardize on the \pkg{TSdbi} API so that it is easier
to move among different database engines.

While it may not be necessary to \code{detach} packages, the following prevents
warnings later about objects being masked:
\begin{Scode}{eval=FALSE}
  detach(package:TSpadi)
\end{Scode}
%%
\subsection{TS PADI Server}
%%
Building a padi server will require some programming effort. 
The padi interface is getting to be fairly old and, although it still works,
some of the underlying code should probably be replaced with a newer approach,
perhaps based on something like SOAP.

Code and a description of a prototype of a standard for a Time Series
Protocol for Application - Database Interface (TS PADI) 
may still be available at \url{http://www.bank-banque-canada.ca/pgilbert}. 
The code includes a working interface to a Fame database. 
%%
\section{Appendix B: Underlying Database Structure and Loading Data}
\label{appdx:B}
%%
More detailed description of the
instructions for building the database tables is given in the vignette 
for the \pkg{TSdbi} package. Those instruction show how to build the database
using database utilites rather than R, which might be the way a
system administrator would build the database.

The database tables are shown in the Table below.
The \textsl{Meta} table is used for storing meta data about series, such as a
description and longer documentation, and also
includes an indication of what table the series data is stored in. To retrieve
series it is not necessary to know which table the series is in, since this can
be found on the \textsl{Meta} table. Putting data on the database may require 
specifying the table, 
if it cannot be determined from the R representation of the series.

\begin{table}
\caption{Data Tables}
\label{tab:tables}
\begin{center}
\begin{tabular}{ll}
\hline
Table & Contents \\
\hline
Meta  & meta data and index to series data tables \\
A     & annual data \\
Q     & quarterly data \\
M     & monthly data \\
S     & semiannual data \\
W     & weekly data \\
D     & daily data \\
B     & business data \\
U     & minutely data \\
I     & irregular data with a date \\
T     & irregular data with a date and time \\
\hline
\end{tabular}
\end{center}
\end{table}

In addition, there will be tables ''vintages'' and ''panels'' if those features
are used.

The following is done with dbConnect in place of a TSconnect, since they
are direct SQL queries and do not require the TSdbi structure.

The structure reported reflects the setup that was done previously.
These queries are Mysql specific but below is a generic SQL way to do this.

\begin{Scode}{results=verbatim}
 library("TSMySQL")
 con <- dbConnect("MySQL", dbname="test")
 dbListTables(con)
 dbGetQuery(con, "show tables;")
 dbGetQuery(con, "describe A;")
 dbGetQuery(con, "describe B;")
 dbGetQuery(con, "describe D;")
 dbGetQuery(con, "describe M;")
 dbGetQuery(con, "describe Meta;")
 dbGetQuery(con, "describe U;")
 dbGetQuery(con, "describe Q;")
 dbGetQuery(con, "describe S;")
 dbGetQuery(con, "describe W;")
\end{Scode}

If schema queries  are supported then table information can be obtained in a
(almost) generic SQL way. On some systems this will fail because users
do not have read priveleges on the INFORMATION\_SCHEMA table. This does not seem
to be an issue in SQLite, but SQLite schema queries are not the same as for
other SQL engines.

\begin{Scode}{results=verbatim}
  dbGetQuery(con, paste(
       "SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.Columns ",
       " WHERE TABLE_SCHEMA='test' AND table_name='A' ;")) 

  dbGetQuery(con, paste(
       "SELECT COLUMN_NAME, COLUMN_DEFAULT, COLLATION_NAME, DATA_TYPE,",
       "CHARACTER_SET_NAME, CHARACTER_MAXIMUM_LENGTH, NUMERIC_PRECISION",
 "FROM INFORMATION_SCHEMA.Columns WHERE TABLE_SCHEMA='test' AND table_name='A' ;"))

  dbGetQuery(con, paste(
   "SELECT COLUMN_NAME, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH, NUMERIC_PRECISION",
 "FROM INFORMATION_SCHEMA.Columns WHERE TABLE_SCHEMA='test' AND table_name='M';"))
\end{Scode}

%%
%%
%%
\section{Appendix C: Examples Using DBI and direct SQL Queries}
\label{appdx:C}
%%
The following examples are queries using the underlying "DBI" functions.
They should not often be needed to access time series, but may be useful
to get at more detailed information, or formulate special queries. Typically
these queries may be more useful for systems administrators doing database 
maintenance than they are for end users.

These queries depend on the underlying structure of the database, which should be
considered ``opague'' from the perspective of a TSdbi user. That is, this structure
could be changed without affecting the TSdbi functionality, but the following
queries would be affected.

\begin{Scode}{results=verbatim}
 library("TSMySQL")
 con <- TSconnect("MySQL", dbname="test") 
 dbGetQuery(con, "SELECT count(*) FROM Meta ;") 
 dbGetQuery(con, "SELECT max(year) FROM A ;") 
\end{Scode}

Finally, to disconnect gracefully, one should
\begin{Scode}{results=hide}
dbDisconnect(con)
\end{Scode}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{apalike}
%%abbrv    apalike  plain    unsrt alpha ieeetr siam newapa
\setlength{\bibsep}{3pt}
\bibliography{Guide}

\end{document}

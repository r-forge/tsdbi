\documentclass[english]{article}
\newcommand{\code}{\emph}
\newcommand{\pkg}{\textsl}
\title{Time Series Database Interface Illustrations}
\begin{document}
\maketitle
%\VignetteIndexEntry{TSdata Guide}
\SweaveOpts{eval=TRUE,echo=TRUE,results=hide,fig=FALSE}
%\SweaveOpts{eval=TRUE,echo=TRUE,results=verbatim,fig=TRUE}
\begin{Scode}{echo=FALSE,results=hide}
 options(continue="  ")
\end{Scode}


NEEDS LOT OF CLEANUP

\section{Introduction}


This vignette illustrates the various  \pkg{TSdbi} packages using time series 
data from several sources. The main purpose of \pkg{TSdbi} is to provide a
common \emph{API}, so the simplicity of changing the data source is a primary
feature. 
The vignette also illustrates some simple time series
manipulation and plotting using packages tframe and tfplot.

To generate this vignette requires most of the \pkg{TS*} packages, but typically
users will only need one, or a few of the packages. For example, a time series
database can be built using one of several SQL database backends, so this might
be done with one of packages \pkg{TSPostgreSQL}, \pkg{TSMySQL}, \pkg{TSSQLite}, 
\pkg{TSodbc}, or \pkg{TSOracle}, but usually not all of them. See the 
vignette in \pkg{TSdbi} for an explanation of the underlying 
database tables.
On the other hand, packages \pkg{TSgetSymbol}, \pkg{TShistQuote}, \pkg{TSxls}, 
and \pkg{TSzip} can be used to pull data from various Internet
sources, so a user might use all of these.

It should be possible to view the pdf version of the guide for this 
package with \emph{print(vignette("TSdata"))}, or directly from CRAN. Many parts
of the vignette can be run by loading the appropriate packages, but some
examples use data that has been loaded in a database for the purpose of these
examples, and it will not be possible to reproduce those examples without the
underlying database.

The first section of this vignette illustrates packages that pull data from
various Internet sources. This currently includes \pkg{TSgetSymbol}, 
\pkg{TShistQuote}, \pkg{TSxls}, and \pkg{TSzip}, but others are in progress.

The second section illustrates the SQL packages \pkg{TSPostgreSQL}, 
\pkg{TSMySQL}, \pkg{TSSQLite}, and \pkg{TSodbc}. These use a very standard SQL
table structure and syntax, so it should be possible to use other SQL backends.
The package \pkg{TSOracle} is available on R-forge at 
\url{http://tsdbi.r-forge.r-project.org/} but I currently am not able to test it
properly. An Appendix desrcibes the underlying database structure, and loading
data into the database.

The third section illustrates packages \pkg{TSfame} and \pkg{TSpadi} which
provide a mechanism to ''wrap'' a Fame database to make it compatable with the
common \pkg{TSdbi} interface.

%%The fourth section illustrates package \pkg{TScompare} for comparing time
%%series databases.

\section{Time Series Data from the Internet}

\section{TSgetSymbol}
 \begin{Scode}{fig=FALSE}
library("TSgetSymbol")  
\end{Scode}
This will also load required packages \pkg{TSdbi}, \pkg{DBI}, 
\pkg{methods}, \pkg{tframePlus}, \pkg{zoo}, and \pkg{quantmod}.

\pkg{TSgetSymbol} is just a wrapper to \code{getSymbols} in \pkg{quantmod}. 
It does not provide
extra functionality, only an interface that is consistent with \pkg{TSdbi}.
\pkg{TSgetSymbol} does not support writing data.


\section{TSjson (with Statistics Canada)}

\pkg{TSjson} provides an interface that is consistent with \pkg{TSdbi} for 
using json objects returned by some servers, or passed by servers that provide
a proxy interface to other databases. 
\pkg{TSjson} does not support writing data to the database.

\begin{Scode}
require("TSjson")
require("tfplot")

# user/passwd host from file ~/.TSjson.cfg
con <- TSconnect("json", dbname="statcan")

# quarterly
x <- TSget("v498086", con)
tfplot(x)
\end{Scode}


\section{TSgetSymbol}

\subsection{TSgetSymbol with FRED}

A connection can be used to get data from the Federal Reserve Bank of St.Louis. 
(Look at http://research.stlouisfed.org/fred2/ to find series identifiers.)

\begin{Scode}
  con <- TSconnect("getSymbol", dbname="FRED") 
  x <- TSget("M2", con)
  plot(x)
\end{Scode}
\begin{Scode}
  require("tfplot")
  tfplot(x)
  TSrefperiod(x) 
  TSdescription(x) 
\end{Scode}

It is also possible to specify a connection to be used as the default:

\begin{Scode}
  options(TSconnection=con)
  tfOnePlot(percentChange(TSget(serIDs="M2"), lag=52), 
    Title = "Running commentary, blah, blah, blah", 
    subtitle="Broad Money (M2)",
    ylab= "y/y percent change*",
    source="Source: Federal Reserve Bank of St.Louis (M2)",
    footnoteLeft = "seasonally adjusted data",
    footnoteRight = "* approximated by 52 week growth",
    lastObs = TRUE )
\end{Scode}

It is also possible to return multiple series, but beware that the FRED 
series called M2 is a weekly series, whereas CPIAUCNS is monthly. Binding
together series of different frequency may fail, or produce strange results.

\begin{Scode}
  x <- TSget(c("CPIAUCNS","M2SL"), con)
  tfplot(x, 
    Title = "Running commentary, blah, blah, blah", 
    subtitle=c("Consumer Price Index for All Urban Consumers: All Items", "Broad Money"),
    ylab= c("Index 1982-84=100", "Billions of dollars"),
    source= c("Data Source: Federal Reserve Bank of St.Louis (CPIAUCNS)",
              "Data Source: Federal Reserve Bank of St.Louis (M2SL)"),
    footnoteLeft  = c("not seasonally adjusted",  "seasonally adjusted"),
    footnoteRight = paste("Extracted:", date()),
    lastObs = TRUE )
  TSdescription(x) 
\end{Scode}


\begin{Scode}{results=verbatim,fig=FALSE}
  TSdates(c("CPIAUCNS","M2SL"), con) # note default start
\end{Scode}

The folowing connects to yahoo and loads Ford. 
This is a multivariate time series with open, close, etc.
Set \code{par(ask=TRUE)} here if you want to stop and prompt for <Return>
between pages in the graphics output.

\begin{Scode}
  yahoo <- TSconnect("getSymbol", dbname="yahoo") 
  x <- TSget("F", con=yahoo)
  plot(x)
\end{Scode}

\begin{Scode}
  tfplot(x, graphs.per.page=3)
\end{Scode}

\section{TShistQuote}

\begin{Scode}{results=verbatim,fig=FALSE}
library("TShistQuote")  
\end{Scode}
This will also load required packages \pkg{TSdbi}, \pkg{DBI}, 
\pkg{methods}, \pkg{tframePlus}, \pkg{zoo}, and \pkg{tseries}.

\pkg{TShistQuote} is just a wrapper to \code{get.hist.quote}. It does not provide
extra functionality, only an interface that is consistent with \pkg{TSdbi}.
\pkg{TShistQuote} does not support writing data to the source URL.

\section{Examples  Using TSdbi with ets}

\begin{Scode}{results=verbatim,fig=TRUE}
  con <- TSconnect("histQuote", dbname="yahoo") 
  x <- TSget("^ftse", con)
  plot(x)
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
  require("tfplot")
  tfplot(x)
  TSrefperiod(x) 
  TSdescription(x) 
\end{Scode}

It is also possible to specify a connection to be used as the default:

\begin{Scode}{results=verbatim,fig=TRUE}
  options(TSconnection=con)
  tfplot(TSget(serIDs="^ftse"))
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
  x2 <- TSget("^gspc", con)
  tfplot(x2)
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
  plot(x2)
  TSdescription(x2) 
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
  x <- TSget(c("^ftse","^gspc"), con)
  plot(x)
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
  tfplot(x)
  TSdescription(x) 
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
  x <- TSget("ibm", con, quote = c("Close", "Vol"))
  tfplot(x)
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
  tfplot(x, xlab = TSdescription(x))
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
  tfplot(x, Title="IBM", start="2007-01-01")
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
  tfplot(x, Title=TSdoc(x), xlab = TSlabel(x), start="2007-01-01")
\end{Scode}

Oanda has maximum of 500 days, so the start date is specified here so as to
not exceed that.

\begin{Scode}{results=verbatim,fig=TRUE}
  conO <- TSconnect("histQuote", dbname="oanda") 
  z <- TSget("EUR/USD", conO, start=Sys.Date() - 495)
  tfplot(z)
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
  tfplot(z, Title = "EUR/USD")
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
  tfplot(z, Title = "EUR/USD", start="2007-01-01")
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
  tfplot(z, Title = "EUR/USD", start="2007-03-01")
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
  tfplot(z, Title = "EUR/USD", start=Sys.Date()-14, end=Sys.Date(),
     xlab = format(Sys.Date(), "%Y"))
  TSdates(c("^ftse","^gspc", "ibm"), con) # note default start
\end{Scode}


\section{TSxls}

\begin{Scode}
library("TSxls")  
\end{Scode}
This will also load required packages \pkg{TSdbi}, \pkg{DBI}, 
\pkg{methods}, \pkg{tframePlus}, and \pkg{zoo}.

\pkg{TSxls} provides methods for the \pkg{TSdbi} interface, allowing the 
use of spreadsheets as if they are a database. (This is a poor substitute for a real database, but is sometimes convenient.)
\pkg{TSxls} does not support writing data to the spreadsheet, but see \code{writeXLS} to write a new spreadsheet. The spreedsheet can be a remote
file which is retrieved when the connection is established.

\subsection{TSxls Examples using Reserve Bank of Australia data}

The following retrieves the file and maps the elements that are used: data, 
dates, identifiers, and series names. The mechanism for converting the data to
an \pkg{R} time series object is also set by the function defined 
in the argument \code{tsrepresentation}.
\begin{Scode}{results=verbatim}
  con <- TSconnect("xls",
          dbname="http://www.rba.gov.au/statistics/tables/xls/d03hist.xls",
          map=list(ids  =list(i=11,     j="B:Q"), 
	           data =list(i=12:627, j="B:Q"), 
	           dates=list(i=12:627, j="A"),
                   names=list(i=4:7,    j="B:Q"), 
		   description = NULL,
		   tsrepresentation = function(data,dates){
		       ts(data,start=c(1959,7), frequency=12)}))
\end{Scode}
Beware that data is read into \pkg{R} when the connection is established, so
changes in the spreadsheet will not be visible in \pkg{R} until a new connection
is established.

Once the connection is established, data can be read from it with the same
functions as for other \pkg{TSdbi} packages.
\begin{Scode}{results=verbatim,fig=TRUE}
  x <- TSget("DMACN", con)
  require("tfplot")
  tfplot(x)

  x <- TSget(c("DMAM1N", "DMAM3N"), con)
  tfplot(x)
  TSdescription(x) 
\end{Scode}

It is also possible to specify a connection to be used as the default:

\begin{Scode}{results=verbatim,fig=TRUE}
  options(TSconnection=con)
  tfplot(TSget(serIDs="DMAM1N"))
\end{Scode}

It is then not necessary to specify the \code{con} when the default is to 
be used.
\begin{Scode}{results=verbatim,fig=TRUE}
  x2 <- TSget("DMAM3N")
  tfplot(x2)
  plot(x2)
  TSdescription(x2) 
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
  x <- TSget("DMAM1N")
  tfplot(x)
  tfplot(x, xlab = TSdescription(x))
  tfplot(x, Title="Australia M1", start=c(2000,1))
  tfplot(x, Title=TSdoc(x), xlab = TSlabel(x), start=c(2000,1))
\end{Scode}

The function \code{plot} puts all series on the same graph whereas
 \code{tfplot} treats each series in the first argument as panels to be
 plotted.
\begin{Scode}{results=verbatim,fig=TRUE}
  x <- TSget(c("DMAM1N", "DMAM3N", "DMABMN","DMAM1S","DMAM3S","DMABMS"))
  plot(x)
  tfplot(x, Title="Australian Monetary Aggregates", graphs.per.page=3)
  TSdescription(x) 
\end{Scode}

\code{tfplot} treats subsequent time series arguments as objects that should be plot on the same panels (so the number of series in each object must be 
the same.
\begin{Scode}{results=verbatim,fig=TRUE}
  tfplot(TSget(c("DMAM1S", "DMAM3S", "DMABMS")),
         TSget(c("DMAM1N", "DMAM3N", "DMABMN")),
    Title="Australian Monetary Aggregates")
\end{Scode}

It is possible to put all series on the same graph.
\begin{Scode}{results=verbatim,fig=TRUE}
  tfplot(TSget("DMAM1S"),
         TSget("DMAM3S"),
         TSget("DMABMS"),
	 TSget("DMAM1N"),
         TSget("DMAM3N"),
         TSget("DMABMN"),
    Title="Australian Monetary Aggregates")
\end{Scode}

\begin{Scode}{results=verbatim}
  TSdates(c("DMAM1N", "DMAM3N"), con) 
\end{Scode}

\section{TSzip}

\begin{Scode}
library("TSzip")  
\end{Scode}
This will also load required packages \pkg{TSdbi}, \pkg{DBI}, 
\pkg{methods}, \pkg{tframePlus}, and \pkg{zoo}.

\pkg{TSzip} provides methods for the \pkg{TSdbi} interface, allowing the 
use of zipped files that can be read by \code{read.table} as if each file is a
database series (or group of series such as high, low, open, close, for a
stock). The \code{dbname} is a directory or \code{url}. 
\pkg{TSzip} does not support writing data to the database. 

\subsection{TSzip Examples using $\Pi$trading data}

The following retrieves zipped files 
from \code{http://pitrading.com/free\_market\_data.htm} which 
provides some end of day data free of charge. (Disclaimer: This site is used as an example. Other than using this free data, I have no association with the company.) 
\begin{Scode}{results=verbatim}
 con <- TSconnect("zip", dbname="http://pitrading.com/free_eod_data")
\end{Scode}

Once the connection is established, data can be read from it with the same
functions as for other \pkg{TSdbi} packages.
\begin{Scode}{results=verbatim,fig=TRUE}
  z <- TSget("INDU", con)
  require("tfplot")
  tfplot(z, graphs.per.page=3)

  z <- TSget(c("EURUSD", "GBPUSD"), con)
  tfplot(z, graphs.per.page=3)

  z <- TSget(c("EURUSD", "GBPUSD"), con, select="Close")
  tfplot(z, Title="EURUSD and GBPUSD closing values from pitrading", start="1995-01-01")
 
  TSrefperiod(z) 
  TSdescription(z) 
\end{Scode}

It is also possible to specify a connection to be used as the default, so
it is then not necessary to specify the \code{con} when the default is used: 

\begin{Scode}{results=verbatim,fig=TRUE}
  options(TSconnection=con)
  tfplot(TSget(serIDs="INDU", select="High"),
         TSget(serIDs="INDU", select="Low"),
	 Title="INDU High and Low", 
	 ylab="Dow Jones Index", 
	 start="1997-01-01")
\end{Scode}



\section{SQL Time Series Databases}
The packages \pkg{TSPostgreSQL}, \pkg{TSMySQL}, \pkg{TSSQLite}, and \pkg{TSodbc}
use underlying packages \pkg{RPostgreSQL}, \pkg{RMySQL}, \pkg{RSQLite}, and
\pkg{RODBC} to provide access to an SQL database with an underlying table
structure which is set up to store time series data. The first subsection of this
section describes the slight variations on the mechanism for establishing the
connection to the different underlying databases. The second subsection illustrates
the use of the \pkg{TSdbi} interface, which is common to all underlying
packages, and the third subsection describes the underlying database structure,
which will be helpful to anyone

\subsection{Connecting to the Database}

\subsection{Using Data from a TSdbi SQL database}

\begin{Scode}
library("TSdata")  
\end{Scode}
This will also load required packages \pkg{TSdbi}, \pkg{DBI}, \pkg{RPostgreSQL}, 
\pkg{methods}, and \pkg{tframe}. 
Some examples below also require \pkg{zoo}, and \pkg{tseries}.

WARNING: running these example will overwrite data in the
database.

The PostgreSQL  user, and password, should be set in PostgreSQL 
configuration file (.pgpass) before starting R. 
The Postgress documentation suggests that it should be
possible to get the host from the .pgpass file too, but I have not been able
to make that work. The PostgreSQL alternative to the configuration file
is to use environment variables PGDATABASE, PGHOST, PGPORT, and PGUSER.
This package (and CRAN) support another alternatively to set this information 
with environment variables  POSTGRES\_USER, POSTGRES\_PASSWD 
and POSTGRES\_HOST.
(An environment variable POSTGRES\_DATABASE can also be set, but ''test'' is
specified below.)  Below, the environment variable  POSTGRES\_USER is used to
determine how the user and password are set. If this environment variable is
empty then it is assumed the PostgreSQL mechanism will be used (i.e. the driver
consults the PG* variables or the configuration file). However, the host is
determined by the following logic:

\begin{Scode}
   user    <- Sys.getenv("POSTGRES_USER")
   host    <- Sys.getenv("POSTGRES_HOST")
   if ("" == host) host  <- Sys.getenv("PGHOST")
   if ("" == host) host  <- "localhost"  #Sys.info()["nodename"] 
   if ("" != user)  passwd  <- Sys.getenv("POSTGRES_PASSWD")
\end{Scode}


\subsection{Using Data from a TSdbi SQL database}

This section gives several simple examples of putting series on and reading them
from the database. (If a large number of series are to be loaded into a database,
one would typically do this with a batch process using the database program's
utilities for loading data.)
The first thing to do is to establish a connection to the database:

\begin{Scode}{results=hide}
 m <- dbDriver("PostgreSQL")
 con <-  if ("" == user) TSconnect(m, dbname="test", host=host) else
    TSconnect(m, dbname="test", user=user, password=passwd, host=host)
\end{Scode}

\code{TSconnect} uses \code{dbConnect} from the \pkg{DBI} package, but checks that the
database has expected tables, and checks for additional features. (It cannot
be used before the tables are created, as done in the previous section.)

This puts a series called \code{vec}  on the database and then reads is back
 
\begin{Scode}
 z <- ts(rnorm(10), start=c(1990,1), frequency=1)
 seriesNames(z) <- "vec"
 if(TSexists("vec", con)) TSdelete("vec", con) 
 TSput( z, con)
 z <- TSget("vec", con)
\end{Scode}
If the series is printed it is seen to be a "ts" time series with some extra
attributes.

\code{TSput} fails if the series already exists on the \code{con}, 
so the above example checks and deletes the series if it already exists. 
\code{TSreplace} does not fail if the series does
not yet exist, so examples below use it instead. Several plots below show
original data and the data retrieved after it is written to the database. One is
added to the original data so that both lines are visible.

And now more examples:

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(20),10,2), start=c(1990,1), frequency=1)
 seriesNames(z) <- c("matc1", "matc2")
 TSreplace(z, con)
 TSget("matc1", con)
 TSget("matc2", con)
 TSget(c("matc1","matc2"), con)
 require("tfplot")
 tfplot(z+1, TSget(c("matc1","matc2"), con), 
          lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(20),10,2), start=c(1990,1), frequency=4)
  seriesNames(z) <- c("matc1", "matc2")
 TSreplace(z, con)
 TSget(c("matc1","matc2"), con)
 tfplot(z+1, TSget(c("matc1","matc2"), con),
          lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(200),100,2), start=c(1995,1), frequency=12)
  seriesNames(z) <- c("mat2c1", "mat2c2")
 TSreplace(z, con)
 tfplot(z+1, TSget(c("mat2c1","mat2c2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}
 
The following extract information about the series from the database, although
not much information has been added for these examples. 
\begin{Scode}{results=verbatim}
 TSmeta("mat2c1", con)
 TSmeta("vec", con)
 TSdates("vec", con)
 TSdescription("vec", con)
 TSdoc("vec", con)
\end{Scode}
Below are examples that make more use of \code{TSdescription} and code{TSdoc}.

Often it is convenient to set the default connection:
\begin{Scode}
 options(TSconnection=con)
\end{Scode}
and then the \code{con} specification can be omitted from the function calls
unless another connection is needed. The \code{con} can still be specified, and
some examples below do specify it, just to illustrate the alternative syntax.
\begin{Scode}{results=verbatim}
 z <- TSget("mat2c1") 
 TSmeta("mat2c1")
\end{Scode}

Data documentation can be in two forms, a description specified by 
\code{TSdescription}
or longer documentation specified by \code{TSdoc}. These can be added to the time
series object, in which case they will be written to the database when
\code{TSput} or \code{TSreplace} is used to put the series on the database. 
Alternatively, they
can be specified as arguments to \code{TSput} or \code{TSreplace}.
The description or documentation will be retrieved as part of the series object
with \code{TSget} only if this is specified with the logical arguments
\code{TSdescription} and \code{TSdoc}. They can also be retrieved directly from the
database with the functions \code{TSdescription} and \code{TSdoc}.

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(10),10,1), start=c(1990,1), frequency=1)
 TSreplace(z, serIDs="Series1", con) 
 zz <- TSget("Series1", con)
 TSreplace(z, serIDs="Series1", con, 
     TSdescription="short rnorm series", 
     TSdoc="Series created as an example in the vignette.")
 zz <- TSget("Series1", con, TSdescription=TRUE, TSdoc=TRUE)
 start(zz)
 end(zz)
 TSdescription(zz)
 TSdoc(zz)

 TSdescription("Series1", con)
 TSdoc("Series1", con)

 z <- ts(rnorm(10), start=c(1990,1), frequency=1)
 seriesNames(z) <- "vec"
 TSreplace(z, con)
 zz <- TSget("vec", con)

 z <- ts(matrix(rnorm(20),10,2), start=c(1990,1), frequency=1)
 seriesNames(z) <- c("matc1", "matc2")
 TSreplace(z, con) 
 tfplot(z+1, TSget(c("matc1","matc2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))

\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(20),10,2), start=c(1990,1), frequency=4)
 seriesNames(z) <- c("matc1", "matc2")
 TSreplace(z, con)
 tfplot(z+1, TSget(c("matc1","matc2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))

\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(200),100,2), start=c(1995,1), frequency=12)
 seriesNames(z) <- c("mat2c1", "mat2c2")
 TSreplace(z, con) 
 tfplot(z+1, TSget(c("mat2c1","mat2c2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}

The following examples use dates and times which are not handled by \code{ts},
so the \pkg{zoo} time representation is used.

\begin{Scode}{results=verbatim,fig=TRUE}
require("zoo") 

 z <- zoo(matrix(rnorm(200),100,2), as.Date("1990-01-01") + 0:99)
  seriesNames(z) <- c("zooc1", "zooc2")
 TSreplace(z, con, Table="D")
 tfplot(z+1, TSget(c("zooc1","zooc2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))
  
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- zoo(matrix(rnorm(200),100,2), as.Date("1990-01-01") + 0:99 * 7)
  seriesNames(z) <- c("zooWc1", "zooWc2")
 TSreplace(z, con, Table="W")
 tfplot(z+1, TSget(c("zooWc1","zooWc2"), con), col=c("black", "red"),
    lty=c("dashed", "solid"))  
\end{Scode}

\begin{Scode}{results=hide}
 dbDisconnect(con)
 #dbUnloadDriver(m)
\end{Scode}

\section{Examples Using Web Data}

This section illustrates fetching data from a web server and loading it into the
database. This would be a very slow way to load a database, but provides
examples of different kinds of time series data. The fetching is done with 
\pkg{TShistQuote} which provides a wrapper for \code{get.hist.quote} from 
package \pkg{tseries} to give syntax consistent with the \pkg{TSdbi}.

Fetching data may fail due to lack of an Interenet connection or delays. 

First establish a connection to the database where data will be saved:
\begin{Scode}
con <-  if ("" == user) TSconnect("PostgreSQL", dbname="test", host=host) else
    TSconnect("PostgreSQL", dbname="test", user=user, password=passwd, host=host)
\end{Scode}

Now connect to the web server and fetch data:

\begin{Scode}{results=verbatim}
  require("TShistQuote")
  Yahoo <- TSconnect("histQuote", dbname="yahoo") 
  x <- TSget("^gspc", quote = "Close", con=Yahoo)
  plot(x)
  tfplot(x)

  TSrefperiod(x) 
  TSdescription(x) 
  TSdoc(x) 
  TSlabel(x) 
  TSsource(x) 
\end{Scode}

Then write the data to the local server, specifying table B for business day 
data (using TSreplace in case the series
is already there from running this example previously):

\begin{Scode}{results=verbatim}
   TSreplace(x,  serIDs="gspc", Table="B", con=con)
\end{Scode}

and check the saved version:

\begin{Scode}{results=verbatim,fig=TRUE}
  TSrefperiod(TSget(serIDs="gspc", con=con)) 
  TSdescription("gspc", con=con) 
  TSdoc("gspc", con=con)
  TSlabel("gspc", con=con) # this is not yet supported on the db
  tfplot(TSget(serIDs="gspc", con=con))
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
   x <- TSget("ibm", quote = c("Close", "Vol"), con=Yahoo)
   TSreplace(x, serIDs=c("ibm.Cl", "ibm.Vol"),  con=con, Table="B",
              TSdescription.=c("IBM Close","IBM  Volume"),
	      TSdoc.= paste(c(
	         "IBM  Close   retrieved on ",
		 "IBM  Volume retrieved  on "), Sys.Date()))

   z <- TSget(serIDs=c("ibm.Cl", "ibm.Vol"), 
             TSdescription=TRUE, TSdoc=TRUE, con=con)
   TSdescription(z)
   TSdoc(z)
   tfplot(z, xlab = TSdoc(z), Title = TSdescription(z))
   tfplot(z, Title="IBM", start="2007-01-01")
\end{Scode}

Oanda has maximum of 500 days, so the start date is specified here so as to
not exceed that.

\begin{Scode}{results=verbatim}
   Oanda <- TSconnect("histQuote", dbname="oanda") 
   x <- TSget("EUR/USD", start=Sys.Date() - 495, con=Oanda)
   TSreplace(x, serIDs="EUR/USD", Table="D", con=con)
\end{Scode}

Then check the saved version:

\begin{Scode}{results=verbatim,fig=TRUE}
   z <- TSget(serIDs="EUR/USD",TSlabel=TRUE, TSdescription=TRUE,  con=con)
   tfplot(z, Title = TSdescription(z), ylab=TSlabel(z))
   tfplot(z, Title = "EUR/USD", start="2007-01-01")
   tfplot(z, Title = "EUR/USD", start="2007-03-01")
   tfplot(z, Title = "EUR/USD", start=Sys.Date()-14, end=Sys.Date(),
      xlab = format(Sys.Date(), "%Y"))
\end{Scode}

\begin{Scode}{results=hide}
  dbDisconnect(con)
  dbDisconnect(Yahoo)
  dbDisconnect(Oanda)
\end{Scode}


\subsection{Examples  Using TSdbi with ets}

These examples use a database called "ets" which is available at the Bank
of Canada.
This set of examples illustrates how the programs might be used if a larger
database is available. Typically a large database would be installed using
database scripts directly rather than from R with \code{TSput} or
\code{TSreplace}. 

The following are wrapped in \code{if (!inherits(conets, "try-error"))} so that
the vignette will build even when the database is not available. This seems to
require an explicit call to \code{print()}, but that is not usually needed to
display results below. Another artifact of this is that results printed in the
if block do not display until the end of the block.

\begin{Scode}{results=verbatim,fig=TRUE}
  m <- dbDriver("PostgreSQL")
  conets <-  try(if ("" == user) TSconnect(m, dbname="ets", host=host) else
    TSconnect(m, dbname="ets", user=user, password=passwd, host=host))
  if (!inherits(conets, "try-error")) {
  
  options(TSconnection=conets)

  print(TSmeta("M.SDR.CCUSMA02.ST"))

  EXCH.IDs <- t(matrix(c(
 	"M.SDR.CCUSMA02.ST",	 "SDR/USD exchange rate",
 	"M.CAN.CCUSMA02.ST",	 "CAN/USD exchange rate",
 	"M.MEX.CCUSMA02.ST",	 "MEX/USD exchange rate",
 	"M.JPN.CCUSMA02.ST",	 "JPN/USD exchange rate",
 	"M.EMU.CCUSMA02.ST",	 "Euro/USD exchange rate",
 	"M.OTO.CCUSMA02.ST",	 "OECD /USD exchange rate",
 	"M.G7M.CCUSMA02.ST",	 "G7   /USD exchange rate",
 	"M.E15.CCUSMA02.ST",	 "Euro 15. /USD exchange rate"
	), 2, 8))

  print(TSdates(EXCH.IDs[,1]))
  z <- TSdates(EXCH.IDs[,1])
  print(start(z))
  print(end(z))
   
  tfplot(TSget(serIDs="V122646", conets))
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  print(TSdescription(TSget("V122646", TSdescription=TRUE)))
  print(TSdescription("V122646"))

  print(TSdoc(TSget("V122646", TSdoc=TRUE)))
  print(TSdoc("V122646"))

  tfplot(TSget("V122646", names="V122646", conets))
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  z <- TSget("V122646", TSdescription=TRUE)
  tfplot(z, Title=strsplit(TSdescription(z), ","))
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  z <- TSget("SDSP500", TSdescription=TRUE)
  tfplot(z, Title=TSdescription(z))
  plot(z)
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  z <- TSget(c("DSP500","SDSP500"), TSdescription=TRUE)
  tfplot(z, xlab=TSdescription(z))
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  plot(z)
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  ETSgdp    <- annualizedGrowth(aggregate(TSget("V1992067"),
                   nfrequency=4,FUN=mean), lag=4, names="GDP Y/Y Growth")
  tfplot(ETSgdp)
  }  # end if !try-error
\end{Scode}
  
\begin{Scode}{results=hide}
  if (!inherits(conets, "try-error")) {
  #dbDisconnect(conets)
  dbDisconnect(options()$TSconnection)
  options(TSconnection=NULL)
  }  # end if !try-error
\end{Scode}

\section{Examples Using DBI and direct SQL Queries}

The following examples are queries using the underlying "DBI" functions.
They should not often be needed to access time series, but may be useful
to get at more detailed information, or formulate special queries.

\begin{Scode}{results=hide}
 m <- dbDriver("PostgreSQL")
 con <-  if ("" == user) TSconnect(m, dbname="test", host=host) else
    TSconnect(m, dbname="test", user=user, password=passwd, host=host)
 options(TSconnection=con)
\end{Scode}


\begin{Scode}{results=verbatim}
dbListTables(con)
\end{Scode}


If schema queries  are supported then table information can be found in a
generic SQL way, but on some systems this will fail because users
do not have read priveleges on the INFORMATION\_SCHEMA table,
so the following are wrapped in \code{try()}.
(SQLite does not seem to support this at all.)

\begin{Scode}{results=verbatim}
  try( dbGetQuery(con, paste(
       "SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.Columns ",
       " WHERE TABLE_SCHEMA='test' AND table_name='A' ;"))  )

  try( dbGetQuery(con, paste(
       "SELECT COLUMN_NAME, COLUMN_DEFAULT, COLLATION_NAME, DATA_TYPE,",
       "CHARACTER_SET_NAME, CHARACTER_MAXIMUM_LENGTH, NUMERIC_PRECISION",
 "FROM INFORMATION_SCHEMA.Columns WHERE TABLE_SCHEMA='test' AND table_name='A' ;"))  )

  try( dbGetQuery(con, paste(
   "SELECT COLUMN_NAME, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH, NUMERIC_PRECISION",
 "FROM INFORMATION_SCHEMA.Columns WHERE TABLE_SCHEMA='test' AND table_name='M';"))  )

\end{Scode}

Finally, to disconnect gracefully, one should

\begin{Scode}{results=hide}

dbDisconnect(con)

dbDisconnect(options()$TSconnection)
options(TSconnection=NULL)
#dbUnloadDriver(m)
\end{Scode}


\section{Wrapping Time Series Databases}
%%\section{Comparing Time Series Databases}

\section{Appendix A: Underlying Dtabase Structure and Loading Data}

WARNING: running these example will overwrite tables in the
PostgreSQL ''test'' database on the server.

The next small section of code is necessary to setup database tables that are
used in the examples below. It
needs to be done only once for a database and might typically be done by
an administrator setting up the database, rather than by an end user. 

\begin{Scode}{results=hide}
m <- dbDriver("PostgreSQL")
con <-  if ("" == user) dbConnect(m, dbname="test", host=host) else
    dbConnect(m, dbname="test", user=user, password=passwd, host=host)

source(system.file("TSsql/CreateTables.TSsql", package = "TSdbi"))
dbDisconnect(con)
\end{Scode}

More detailed description of the
instructions for building the database tables is given in the vignette 
for the \pkg{TSdbi} package. Those instruction show how to build the database
using database utilites rather than R, which might be the way a
system administrator would build the database.



\section{Examples  Using TSdbi with TSodbc and ets}

These examples use a database called "ets" which is available at the Bank
of Canada.
This set of examples illustrates how the programs might be used if a larger
database is available. Typically a large database would be installed using
database scripts directly rather than from R with \code{TSput} or
\code{TSreplace}. 

The following are wrapped in \code{if (!inherits(conets, "try-error"))} so that
the vignette will build even when the database is not available. This seems to
require an explicit call to \code{print()}, but that is not usually needed to
display results below. Another artifact of this is that results printed in the
if block do not display until the end of the block.

\begin{Scode}{results=verbatim,fig=TRUE}
  m <- dbDriver("ODBC")
  conets <-  try(if ("" == user) TSconnect(m, dbname="ets") else
    TSconnect(m, dbname="ets", uid=user, pwd=passwd))
  if (!inherits(conets, "try-error")) {
  
  options(TSconnection=conets)

  print(TSmeta(TSget("M.SDR.CCUSMA02.ST")))

  EXCH.IDs <- t(matrix(c(
 	"M.SDR.CCUSMA02.ST",	 "SDR/USD exchange rate",
 	"M.CAN.CCUSMA02.ST",	 "CAN/USD exchange rate",
 	"M.MEX.CCUSMA02.ST",	 "MEX/USD exchange rate",
 	"M.JPN.CCUSMA02.ST",	 "JPN/USD exchange rate",
 	"M.EMU.CCUSMA02.ST",	 "Euro/USD exchange rate",
 	"M.OTO.CCUSMA02.ST",	 "OECD /USD exchange rate",
 	"M.G7M.CCUSMA02.ST",	 "G7   /USD exchange rate",
 	"M.E15.CCUSMA02.ST",	 "Euro 15. /USD exchange rate"
	), 2, 8))

  print(TSdates(EXCH.IDs[,1]))
  z <- TSdates(EXCH.IDs[,1])
  print(start(z))
  print(end(z))
   
  tfplot(TSget(serIDs="V122646", conets))
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  print(TSdescription(TSget("V122646", TSdescription=TRUE)))
  print(TSdescription("V122646"))

  print(TSdoc(TSget("V122646", TSdoc=TRUE)))
  print(TSdoc("V122646"))

  tfplot(TSget("V122646", names="V122646", conets))
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  z <- TSget("V122646", TSdescription=TRUE)
  tfplot(z, Title=strsplit(TSdescription(z), ","))
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  z <- TSget("SDSP500", TSdescription=TRUE)
  tfplot(z, Title=TSdescription(z))
  plot(z)
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  z <- TSget(c("DSP500","SDSP500"), TSdescription=TRUE)
  tfplot(z, xlab=TSdescription(z))
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  plot(z)
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  ETSgdp    <- annualizedGrowth(aggregate(TSget("V1992067"),
                   nfrequency=4,FUN=mean), lag=4, names="GDP Y/Y Growth")
  tfplot(ETSgdp)
  }  # end if !try-error
\end{Scode}
  
\begin{Scode}{results=hide}
  if (!inherits(conets, "try-error")) {
  #dbDisconnect(conets)
  dbDisconnect(options()$TSconnection)
  options(TSconnection=NULL)
  }  # end if try-error
\end{Scode}



\section{TSfame}

I no longer have access to Fame so package \pkg{TSfame} is no longer being
extensively tested. Please contact the package maintainer (Paul Gilbert) if 
you have Fame and are willing to test this package.


WARNING: The code in this vignette is no longer being run to generate the
vignette, since I no longer have access to Fame. The pdf version of the Guide,
circulated with the package, was generated previously.

\section{Introduction}
The code from the vignette that generates this guide can 
be loaded into an editor with \emph{edit(vignette("TSfame"))}.
This uses the default editor, which can be changed using \emph{options()}.
It should be possible to view the pdf version of the guide for this 
package with \emph{print(vignette("TSfame"))}.


WARNING: Running these example will overwrite a fame database called
''testvigFame.db''. Beware, if by any chance you have a database with this name.

Once R is started, the functions in this package are made available with

\begin{Scode}
library("TSfame")  
\end{Scode}
This will also load required packages \pkg{TSdbi}, \pkg{DBI}, \pkg{fame}, 
\pkg{methods}, and \pkg{tframe}. 
Some examples below also require \pkg{zoo}, and \pkg{tseries}.

The package \pkg{fame} may be installed but not functional because the Fame HLI
code is not available. A warning will be issues and the vignette example will
not work,

\section{Using the Database - TSdbi Functions}

This section gives several simple examples of putting series on and reading them
from the database. (If a large number of series are to be loaded into a database,
one would typically do this with a batch process in Fame.)
The first thing to do is to establish a connection to the database:

\begin{Scode}{results=hide}
con <- TSconnect("fame", dbname="testvigFame.db") 
\end{Scode}

(It is also possible to establish connections to Fame databases using Fame 
server. See the section ''Examples Using TSdbi with ets'' below for more 
details.)

This puts a series called \code{vec}  on the database and then reads is back. 
 
\begin{Scode}\begin{Scod
 z <- ts(rnorm(10), start=c(1990,1), frequency=1)
 seriesNames(z) <- "vec"
 if(TSexists("vec", con)) TSdelete("vec", con) 
 TSput( z, con)
 z <- TSget("vec", con)
\end{Scode}
If the series is printed it is seen to be a "ts" time series with some extra
attributes.

\code{TSput} fails if the series already exists on the \code{con}, 
so the above example checks and deletes the series if it already exists. 
\code{TSreplace} does not fail if the series does
not yet exist, so examples below use it instead. Several plots below show
original data and the data retrieved after it is written to the database. One is
added to the original data so that both lines are visible.

And now more examples:

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(20),10,2), start=c(1990,1), frequency=1)
 seriesNames(z) <- c("matc1", "matc2")
 TSreplace(z, con)
 TSget("matc1", con)
 TSget("matc2", con)
 TSget(c("matc1","matc2"), con)
 tfplot(z+1, TSget(c("matc1","matc2"), con), 
          lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(20),10,2), start=c(1990,1), frequency=4)
  seriesNames(z) <- c("matc1", "matc2")
 TSreplace(z, con)
 TSget(c("matc1","matc2"), con)
 tfplot(z+1, TSget(c("matc1","matc2"), con),
          lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(200),100,2), start=c(1995,1), frequency=12)
  seriesNames(z) <- c("mat2c1", "mat2c2")
 TSreplace(z, con)
 require("tfplot")
 tfplot(z+1, TSget(c("mat2c1","mat2c2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}
 
The following extract information about the series from the database, although
not much information has been added for these examples, and not all fields are
supported by the Fame database. (The output is suppressed.)
\begin{Scode}
 TSmeta("mat2c1", con)
 TSmeta("vec", con)
 TSdates("vec", con)
 TSdescription("vec", con)
 TSdoc("vec", con)
 TSlabel("vec", con)
 TSsource("vec", con)
\end{Scode}

Below are examples that make more use of \code{TSdescription} and code{TSdoc}.
Often it is convenient to set the default connection:

\begin{Scode}
 options(TSconnection=con)
\end{Scode}
and then the \code{con} specification can be omitted from the function calls
unless another connection is needed. The \code{con} can still be specified, and
some examples below do specify it, just to illustrate the alternative syntax.

\begin{Scode}{results=verbatim}
 z <- TSget("mat2c1") 
 TSmeta("mat2c1")
\end{Scode}


Data documentation can be in two forms, a description specified by 
\code{TSdescription}
or longer documentation specified by \code{TSdoc}. These can be added to the time
series object, in which case they will be written to the database when
\code{TSput} or \code{TSreplace} is used to put the series on the database. 
Alternatively, they
can be specified as arguments to \code{TSput} or \code{TSreplace}.
The description or documentation will be retrieved as part of the series object
with \code{TSget} only if this is specified with the logical arguments
\code{TSdescription} and \code{TSdoc}. They can also be retrieved directly from the
database with the functions \code{TSdescription} and \code{TSdoc}.

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(10),10,1), start=c(1990,1), frequency=1)
 TSreplace(z, serIDs="Series1", con) 
 zz <- TSget("Series1", con)
 TSreplace(z, serIDs="Series1", con, 
     TSdescription="short rnorm series", 
     TSdoc="Series created as an example in the vignette.")
 zz <- TSget("Series1", con, TSdescription=TRUE, TSdoc=TRUE)
 start(zz)
 end(zz)
 TSdescription(zz)
 TSdoc(zz)

 TSdescription("Series1", con)
 TSdoc("Series1", con)

 z <- ts(rnorm(10), start=c(1990,1), frequency=1)
 seriesNames(z) <- "vec"
 TSreplace(z, con)
 zz <- TSget("vec", con)

 z <- ts(matrix(rnorm(20),10,2), start=c(1990,1), frequency=1)
 seriesNames(z) <- c("matc1", "matc2")
 TSreplace(z, con) 
 tfplot(z+1, TSget(c("matc1","matc2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(20),10,2), start=c(1990,1), frequency=4)
 seriesNames(z) <- c("matc1", "matc2")
 TSreplace(z, con)
 tfplot(z+1, TSget(c("matc1","matc2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(200),100,2), start=c(1995,1), frequency=12)
 seriesNames(z) <- c("mat2c1", "mat2c2")
 TSreplace(z, con) 
 tfplot(z+1, TSget(c("mat2c1","mat2c2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}

The following examples use dates and times which are not handled by \code{ts},
so the \pkg{zoo} time representation is used.

\begin{Scode}{results=verbatim,fig=TRUE}
require("zoo") 

 z <- zoo(matrix(rnorm(200),100,2), as.Date("1990-01-01") + 0:99)
 seriesNames(z) <- c("zooc1", "zooc2")
 TSreplace(z, con)
 tfplot(z+1, TSget(c("zooc1","zooc2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))  
\end{Scode}

Beware that (as of Dec, 2010) there is a bug with weekly dates:
\begin{Scode}{results=verbatim,fig=FALSE}
 z <- zoo(matrix(rnorm(200),100,2), as.Date("1990-01-01") + 0:99 * 7)
 seriesNames(z) <- c("zooWc1", "zooWc2")
 TSreplace(z, con)
 z2 <- TSget(c("zooWc1","zooWc2"), con)
 time(z)
 time(z2)
\end{Scode}

and while this works:
\begin{Scode}{results=verbatim,fig=TRUE}
 tfplot(z2)
\end{Scode}

this may not:
\begin{Scode}{results=verbatim,fig=TRUE}
 tfplot(z+1, z2, col=c("black", "red"), lty=c("dashed", "solid"))  
\end{Scode}


\section{Examples Using Web Data}

This section illustrates fetching data from a web server and loading it into the
database. This would be a very slow way to load a database, but provides
examples of different kinds of time series data. The fetching is done with 
\pkg{TShistQuote} which provides a wrapper for \code{get.hist.quote} from 
package \pkg{tseries} to give syntax consistent with the \pkg{TSdbi}.

Fetching data may fail due to lack of an Interenet connection or delays. 

The connection \code{con} established above to the database will be used to
save data but, to make the use of the two connections more obvious, neither will 
be set as the default:
\begin{Scode}
 options(TSconnection=NULL)
\end{Scode}

Now connect to the web server and fetch data:

\begin{Scode}{results=verbatim}
  require("TShistQuote")
  Yahoo <- TSconnect("histQuote", dbname="yahoo") 
  x <- TSget("^gspc", quote = "Close", con=Yahoo)
  plot(x)
  tfplot(x)

  TSrefperiod(x) 
  TSdescription(x) 
  TSdoc(x) 
\end{Scode}

Then write the data to the local server, specifying table B for business day 
data (using TSreplace in case the series
is already there from running this example previously):

\begin{Scode}{results=verbatim}
   TSreplace(x,  serIDs="gspc", Table="B", con=con)
\end{Scode}

and check the saved version:

\begin{Scode}{results=verbatim,fig=TRUE}
  TSrefperiod(TSget(serIDs="gspc", con=con)) 
  TSdescription("gspc", con=con) 
  TSdoc("gspc", con=con)
  tfplot(TSget(serIDs="gspc", con=con))
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
   x <- TSget("ibm", quote = c("Close", "Vol"), con=Yahoo)
   TSreplace(x, serIDs=c("ibm.Cl", "ibm.Vol"),  con=con, Table="B",
              TSdescription.=c("IBM Close","IBM  Volume"),
	      TSdoc.= paste(c(
	         "IBM  Close   retrieved on ",
		 "IBM  Volume retrieved  on "), Sys.Date()))

   z <- TSget(serIDs=c("ibm.Cl", "ibm.Vol"), 
             TSdescription=TRUE, TSdoc=TRUE, con=con)
   TSdescription(z)
   TSdoc(z)
   tfplot(z, xlab = TSdoc(z), Title = TSdescription(z))
   tfplot(z, Title="IBM", start="2007-01-01")
\end{Scode}

\begin{Scode}{results=hide}
  dbDisconnect(con)
  dbDisconnect(Yahoo)
\end{Scode}


\subsection{Examples Using TSdbi with ets}

These examples use a database called "ets" which is available at the Bank
of Canada.
This set of examples illustrates how the programs might be used if a larger
database is available. Typically a large database would be installed using
database scripts directly rather than from R with \code{TSput} or
\code{TSreplace}. 

The following are wrapped in \code{if (!inherits(con, "try-error"))} so that
the vignette will build even when the database is not available. This seems to
require an explicit call to \code{print()}, but that is not usually needed to
display results below. Another artifact of this is that results printed in the
\code{if} block do not display until the end of the block.

\begin{Scode}{results=verbatim,fig=FALSE}
  conets <- try(TSconnect("fame", dbname="ets /home/ets/db/etsintoecd.db",
                  accessMode="read")) 
  if (!inherits(conets, "try-error")) { 
    print(TSmeta("M.SDR.CCUSMA02.ST", con=conets))
  }
\end{Scode}
The above connection is recognized to be a server because of the white space
between ''ets'' and the database name. This produces a warning message from the
\pkg{fame} package call, because it is guessing that a Fame server call is 
intended. An alternative way to establish the 
connnection is to explicitely indicate that the server functionality is to be 
used:
\begin{Scode}{results=verbatim,fig=FALSE}
  conServer <- try(
    TSconnect("fameServer", dbname="/home/ets/db/etsintoecd.db",
       service = "2959", host = "ets", user="", password="",stopOnFail = TRUE)) 

  if (!inherits(conServer, "try-error")) { 
    print(TSmeta("M.SDR.CCUSMA02.ST", con=conServer))
  }
\end{Scode}

This does not give the warning message, and for that reason will be used below, 
but they are interchangable.

\begin{Scode}{results=verbatim,fig=TRUE}
  if (!inherits(conServer, "try-error")) {
  
  options(TSconnection=conServer)

  print(TSmeta("M.SDR.CCUSMA02.ST"))

  EXCH.IDs <- t(matrix(c(
 	"M.SDR.CCUSMA02.ST",	 "SDR/USD exchange rate",
 	"M.CAN.CCUSMA02.ST",	 "CAN/USD exchange rate",
 	"M.MEX.CCUSMA02.ST",	 "MEX/USD exchange rate",
 	"M.JPN.CCUSMA02.ST",	 "JPN/USD exchange rate",
 	"M.EMU.CCUSMA02.ST",	 "Euro/USD exchange rate",
 	"M.OTO.CCUSMA02.ST",	 "OECD /USD exchange rate",
 	"M.G7M.CCUSMA02.ST",	 "G7   /USD exchange rate",
 	"M.E15.CCUSMA02.ST",	 "Euro 15. /USD exchange rate"
	), 2, 8))

  print(TSdates(EXCH.IDs[,1]))
  z <- TSdates(EXCH.IDs[,1])
  print(start(z))
  print(end(z))
   
  tfplot(TSget(serIDs="M.CAN.CCUSMA02.ST", conServer), 
      ylab="CDN dollors per US dollar",
      Title="Canada - U.S. Exchange Rate")
  }
\end{Scode}


\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conServer, "try-error")) {
  print(TSdescription(TSget("M.CAN.CCUSMA02.ST", TSdescription=TRUE)))
  print(TSdescription("M.CAN.CCUSMA02.ST"))

  print(TSdoc(TSget("M.CAN.CCUSMA02.ST", TSdoc=TRUE)))
  print(TSdoc("M.CAN.CCUSMA02.ST"))

  tfplot(TSget("M.CAN.CCUSMA02.ST", names="M.CAN.CCUSMA02.ST", conServer))
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conServer, "try-error")) {
  z <- TSget("M.CAN.CCUSMA02.ST", TSdescription=TRUE)
  tfplot(z, Title=strsplit(TSdescription(z), "//")[[1]][1:2])
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conServer, "try-error")) {
  plot(z)
  }
\end{Scode}
  
\begin{Scode}{results=hide}
  if (!inherits(conServer, "try-error")) {
  options(TSconnection=NULL)
  }  # end if try-error
\end{Scode}

Finally, dbDisconnect closes the connection if it is a Fame Server connect, and
does nothing otherwise, but is provided for compatability with other connections.

\begin{Scode}{results=hide}
dbDisconnect(conets)
dbDisconnect(conServer)
dbDisconnect(con)
options(TSconnection=NULL)
\end{Scode}

A simple mechanism for accessing vintages of data stored in 
different Fame databases is available as illustrated by the following examples. 

\begin{Scode}{results=verbatim,fig=TRUE}
  dbs <- paste("ets /home/ets5/mfadata/etsmfacansim_", c(
             "20110513.db", "20060526.db", "20110520.db"), sep="")
  names(dbs) <- c("2011-05-13", "2006-05-26", "2011-05-20")
	     
  conetsV <- try(TSconnect("fame", dbname=dbs, "read", current="2011-05-13")) 

  if (!inherits(conetsV, "try-error")) {   
   z <- TSget("V122646", con=conetsV, vintage=c("2011-05-13", "2006-05-26"))
   tfplot(z)
   options(TSconnection=conetsV)
   z <- TSget("V122646") 
   z <- TSget(c("V122646", "V122647")) 
   tfplot(z)
   dbDisconnect(conetsV)
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
  dbs <- paste("/home/ets5/mfadata/etsmfacansim_", c(
             "20110513.db", "20060526.db", "20110520.db"), sep="")
  names(dbs) <- c("2011-05-13", "2006-05-26", "2011-05-20")

  conServerV <- try( TSconnect("fameServer", dbname=dbs, 
            service = "2959", host = "ets", stopOnFail = TRUE)) 

  if (!inherits(conServerV, "try-error")) { 
   r <- TSget("V122646", con=conServerV, vintage=c("2011-05-13", "2006-05-26"))
   tfplot(r)
   dbDisconnect(conServerV)
    
  }
\end{Scode}


\section{TSpadi}

\pkg{TSpadi} has been largely replaced by other TS* packages and is not longer
extensively tested.

\begin{Scode}
library("TSpadi")  
\end{Scode}
This will also load required packages \pkg{TSdbi}, \pkg{DBI}, 
\pkg{methods}, and \pkg{tframe}. 
Some examples below also require \pkg{zoo}, and \pkg{tseries}.

TSpadi is a \pkg{TSdbi} style interface to a server which 
extracts data from a backend database. In these examples,
Fame is the backend database engine. The R client communicates with the 
server using
an RPC based protocol which has been called ''padi'', so only the server 
requires the Fame programs and licences. 

\pkg{TSpadi} does not support writing data to a database, so examples below are
restricted to an already available database. Alternate approaches for interfacing
to Fame are the R packages \pkg{fame} and \pkg{TSfame}. The later is just a 
wrapper for the former, to give it a \pkg{TSdbi} style interface. Both allow
writing to the Fame database, but both also require the Fame HLI programs and
licences for the client R machine.

While \pkg{TSpadi} does not require Fame on the R clients, there is 
additional work to 
set up the padi server and configure it to load databases. Please check 
additional comments in the last section ''TS PADI Server'' before deciding
about using the \pkg{TSpadi} interface (and you may want to contact me, 
Paul Gilbert). I do actively use this interface, but one of the main purposes 
of \pkg{TSpadi} is to standardize on the \pkg{TSdbi} API so that it is easier
to move among different database engines.

\subsection{Examples Using TSdbi with ets}

These examples use a database called "ets" which is available at the Bank
of Canada.
This set of examples illustrates how the programs might be used if a larger
database is available. Typically a large database would be installed using
database scripts directly rather than from R with \code{TSput} or
\code{TSreplace}. 

The following are wrapped in \code{if (!inherits(conets, "try-error"))} so that
the vignette will build even when the database is not available. This seems to
require an explicit call to \code{print()}, but that is not usually needed to
display results below. Another artifact of this is that results printed in the
if block do not display until the end of the block. Also, graphics are not
displayed in the vignette because, when they are not generated, the missing 
file causes an error building the vignette.

\begin{Scode}{results=verbatim,fig=TRUE}
  m <- dbDriver("padi")
  conets <- try(TSconnect(m, dbname="ets")) 
  if (!inherits(conets, "try-error")) {
  
  options(TSconnection=conets)

  # TSdoc("M.SDR.CCUSMA02.ST") not supported for TSpadi
  print(TSmeta("M.SDR.CCUSMA02.ST"))
  
  z <- TSget("M.SDR.CCUSMA02.ST")

  EXCH.IDs <- t(matrix(c(
 	"M.SDR.CCUSMA02.ST",	 "SDR/USD exchange rate",
 	"M.CAN.CCUSMA02.ST",	 "CAN/USD exchange rate",
 	"M.MEX.CCUSMA02.ST",	 "MEX/USD exchange rate",
 	"M.JPN.CCUSMA02.ST",	 "JPN/USD exchange rate",
 	"M.EMU.CCUSMA02.ST",	 "Euro/USD exchange rate",
 	"M.OTO.CCUSMA02.ST",	 "OECD /USD exchange rate",
 	"M.G7M.CCUSMA02.ST",	 "G7   /USD exchange rate",
 	"M.E15.CCUSMA02.ST",	 "Euro 15. /USD exchange rate"
	), 2, 8))

  print(TSdates(EXCH.IDs[,1]))
  z <- TSdates(EXCH.IDs[,1])
  print(start(z))
  print(end(z))
   
  require("tfplot")
  tfplot(TSget(serIDs="V122646", conets))
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  print(TSdescription(TSget("V122646", TSdescription=TRUE)))
  print(TSdoc(TSget("V122646", TSdoc=TRUE)))
  tfplot(TSget("V122646", names="V122646", conets))
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  z <- TSget("V122646", TSdescription=TRUE)
  tfplot(z, Title="Total short-term business credit")
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  ETSgdp    <- annualizedGrowth(aggregate(TSget("V1992067"),
                   nfrequency=4,FUN=mean), lag=4, names="GDP Y/Y Growth")
  tfplot(ETSgdp)
  }  # end if !try-error
\end{Scode}

\section{TS PADI Server}

Building a padi server will require some programming effort. 
The padi interface is getting to be fairly old and, although it still works,
some of the underlying code should probably be replaced with a newer approach,
perhaps based on something like SOAP.

Code and a description of a prototype of a standard for a Time Series
Protocol for Application - Database Interface (TS PADI) 
may still be available at http://www.bank-banque-canada.ca/pgilbert. 
The code includes a working interface to a Fame database. 
\section{TScompare}

Once R is started, the functions in this package are made available with

\begin{Scode}
library("TScompare")  
\end{Scode}
This will also load required packages \pkg{TSdbi}, \pkg{DBI}, 
\pkg{methods}, \pkg{tframePlus}, \pkg{zoo}, and \pkg{tseries}.

The main purpose of this package is to compare pairs of series on two database.
These sereis might have the same name, but for generality the main function, 
\code{TScompare}, is set up to use name pairs. The pairs to compare are 
indicated by a matrix of strings with two columns. Alternately, it would be 
possible to compare pairs on the same database but, other than for testing 
or demonstration purposes, this would not make sense unless the names are 
different. 

The connections are established using other TSdbi packages such as TSMySQL, 
TSpadi, etc. It will be necessary to establish two database connections, 
so it will also be necessary to load the database specific packages. 
In this vignette, examples will use \pkg{TShistQuote},  \pkg{TSMySQL} 
and \pkg{TSSQLite}. 

\begin{Scode}
library("TShistQuote")  
library("TSMySQL")  
library("TSSQLite")  
\end{Scode}


\subsection{Examples using constructed database}

To provide simple examples, \pkg{TShistQuote} is used to extract some series from the web and save them on local databases. First local MySQL andSQLite test databases are created. The next small section of code determines the username and password, or sets them to an empty string if they are to be taken from a configuration file, and sets up the databases. See the vignettes for \pkg{TSMySQL} and \pkg{TSSQLite} for more details and other options to set the username and password.  

\begin{Scode}{results=hide}
  user    <- Sys.getenv("MYSQL_USER")
  if ("" != user) {
      host    <- Sys.getenv("MYSQL_HOST")
      if ("" == host)	  host <- Sys.info()["nodename"] 
      passwd  <- Sys.getenv("MYSQL_PASSWD")
      if ("" == passwd)   passwd <- NULL
     }
  con <-  if ("" == user) dbConnect("MySQL", dbname="test") else
    dbConnect("MySQL", dbname="test", username=user, password=passwd, host=host)

  source(system.file("TSsql/CreateTables.TSsql", package = "TSdbi"))
  dbDisconnect(con)
\end{Scode}

\begin{Scode}{results=hide}
con <- dbConnect("SQLite", dbname="test") 
source(system.file("TSsql/CreateTables.TSsql", package = "TSdbi"))
dbDisconnect(con)
\end{Scode}

Now a TS connection to the database is established.

\begin{Scode}{results=hide}
  con1 <-  if ("" == user) TSconnect("MySQL", dbname="test") else
    TSconnect("MySQL", dbname="test", username=user, password=passwd, host=host)

  con2 <- TSconnect("SQLite", dbname="test") 
\end{Scode} 

Next a connection to yahoo is used to get some series and write them to the local test database. (See the vignette for \pkg{TShistQuote} for more examples of reading series from the web.) \code{TSreplace} is used because \code{TSput} will fail if the series already exisits.

\begin{Scode}{results=verbatim}
  yahoo <- TSconnect("histQuote", dbname="yahoo") 
  x <- TSget("^ftse", yahoo)
  TSreplace(x, serIDs="ftse", Table="B", con=con1)
  TSreplace(x, serIDs="ftse", Table="B", con=con2)

  x <- TSget("^gspc", yahoo)
  TSreplace(x,  serIDs="gspc", Table="B", con=con1)
  TSreplace(x,  serIDs="gspc", Table="B", con=con2)

  x <- TSget("ibm", con=yahoo, quote = c("Close", "Vol"))
  TSreplace(x, serIDs=c("ibmClose", "ibmVol"), Table="B", con=con1)
  TSreplace(x, serIDs=c("ibmC",     "ibmV"),   Table="B", con=con2)
\end{Scode}

Now to do a comparison

\begin{Scode}{results=verbatim}
  ids <- AllIds(con1)
  print(ids)
\end{Scode}

If the second database has the same names then ids can be made into a 
matrix with identical columns. 

\begin{Scode}{results=verbatim}
  ids <- cbind(ids, ids)

  eq   <- TScompare(ids, con1, con2, na.rm=FALSE)
  print(summary(eq))

  eqrm <- TScompare(ids, con1, con2, na.rm=TRUE)
  print(summary(eqrm))
\end{Scode}

Since names are not identical the above indicates discrepancies, which 
are resolves by indicating the corresponding name pairs.

\begin{Scode}{results=verbatim}
  ids <- matrix(c("ftse","gspc","ibmClose", "ibmVol",
                  "ftse","gspc","ibmC", "ibmV"),4,2)

  ids
  eq   <- TScompare(ids, con1, con2, na.rm=FALSE)
  print(summary(eq))

  eqrm <- TScompare(ids, con1, con2, na.rm=TRUE)
  print(summary(eqrm))
\end{Scode}

\subsection{Examples using ets database}
FROM TSMySQL


WARNING: running these example will overwrite tables in the
MySQL ''test'' database on the server.

Once R is started, the functions in this package are made available with

\begin{Scode}
library("TSMySQL")  
\end{Scode}
This will also load required packages \pkg{TSdbi}, \pkg{DBI}, \pkg{RMySQL}, 
\pkg{methods}, and \pkg{tframe}. 
Some examples below also require \pkg{zoo}, and \pkg{tseries}.

The MySQL  user, password, and hostname should be set in MySQL client
configuration file
(.my.cnf) before starting R. Alternatively, this information can be set with
environment variables  MYSQL\_USER, MYSQL\_PASSWD and MYSQL\_HOST.
(An environment variable MYSQL\_DATABASE can also be set, but ''test'' is
specified below.) Below, the environment variable  MYSQL\_USER is used to
determine which of these methods is being used. If this environment variable is
empty then it is assumed the configuration file will be used.

\begin{Scode}
   user    <- Sys.getenv("MYSQL_USER")
   if ("" != user) {
       host    <- Sys.getenv("MYSQL_HOST")
       if ("" == host)     host <- Sys.info()["nodename"] 
       passwd  <- Sys.getenv("MYSQL_PASSWD")
       if ("" == passwd)   passwd <- NULL
      }
\end{Scode}

The next small section of code is necessary to setup database tables that are
used in the examples below. It
needs to be done only once for a database and might typically be done by
an administrator setting up the database, rather than by an end user. 

\begin{Scode}{results=hide}
m <- dbDriver("MySQL")
con <-  if ("" == user) dbConnect(m, dbname="test") else
    dbConnect(m, dbname="test", username=user, password=passwd, host=host)

source(system.file("TSsql/CreateTables.TSsql", package = "TSdbi"))
dbDisconnect(con)
\end{Scode}

More detailed description of the
instructions for building the database tables is given in the vignette 
for the \pkg{TSdbi} package. Those instruction show how to build the database
using database utilites rather than R, which might be the way a
system administrator would build the database.

\section{Using the Database - TSdbi Functions}

This section gives several simple examples of putting series on and reading them
from the database. (If a large number of series are to be loaded into a database,
one would typically do this with a batch process using the database program's
utilities for loading data.)
The first thing to do is to establish a connection to the database:

\begin{Scode}{results=hide}
con <-  if ("" == user) TSconnect("MySQL", dbname="test") else
    TSconnect("MySQL", dbname="test", username=user, password=passwd, host=host)
\end{Scode}

\code{TSconnect} uses \code{dbConnect} from the \pkg{DBI} package, but checks that the
database has expected tables, and checks for additional features. (It cannot
be used before the tables are created, as done in the previous section.)

This puts a series called \code{vec}  on the database and then reads is back
 
\begin{Scode}
 z <- ts(rnorm(10), start=c(1990,1), frequency=1)
 seriesNames(z) <- "vec"
 if(TSexists("vec", con)) TSdelete("vec", con) 
 TSput( z, con)
 z <- TSget("vec", con)
\end{Scode}
If the series is printed it is seen to be a "ts" time series with some extra
attributes.

\code{TSput} fails if the series already exists on the \code{con}, 
so the above example checks and deletes the series if it already exists. 
\code{TSreplace} does not fail if the series does
not yet exist, so examples below use it instead. Several plots below show
original data and the data retrieved after it is written to the database. One is
added to the original data so that both lines are visible.

And now more examples:

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(20),10,2), start=c(1990,1), frequency=1)
 seriesNames(z) <- c("matc1", "matc2")
 TSreplace(z, con)
 TSget("matc1", con)
 TSget("matc2", con)
 TSget(c("matc1","matc2"), con)
 require("tfplot")
 tfplot(z+1, TSget(c("matc1","matc2"), con), 
          lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(20),10,2), start=c(1990,1), frequency=4)
  seriesNames(z) <- c("matc1", "matc2")
 TSreplace(z, con)
 TSget(c("matc1","matc2"), con)
 tfplot(z+1, TSget(c("matc1","matc2"), con),
          lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(200),100,2), start=c(1995,1), frequency=12)
  seriesNames(z) <- c("mat2c1", "mat2c2")
 TSreplace(z, con)
 tfplot(z+1, TSget(c("mat2c1","mat2c2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}
 
The following extract information about the series from the database, although
not much information has been added for these examples. 
\begin{Scode}
 TSmeta("mat2c1", con)
 TSmeta("vec", con)
 TSdates("vec", con)
 TSdescription("vec", con)
 TSdoc("vec", con)
\end{Scode}

Below are exampoles that make more use of \code{TSdescription} and code{TSdoc}.

Often it is convenient to set the default connection:

\begin{Scode}
 options(TSconnection=con)
\end{Scode}
and then the \code{con} specification can be omitted from the function calls
unless another connection is needed. The \code{con} can still be specified, and
some examples below do specify it, just to illustrate the alternative syntax.

\begin{Scode}{results=verbatim}
 z <- TSget("mat2c1") 
 TSmeta("mat2c1")
\end{Scode}


Data documentation can be in two forms, a description specified by 
\code{TSdescription}
or longer documentation specified by \code{TSdoc}. These can be added to the time
series object, in which case they will be written to the database when
\code{TSput} or \code{TSreplace} is used to put the series on the database. 
Alternatively, they
can be specified as arguments to \code{TSput} or \code{TSreplace}.
The description or documentation will be retrieved as part of the series object
with \code{TSget} only if this is specified with the logical arguments
\code{TSdescription} and \code{TSdoc}. They can also be retrieved directly from the
database with the functions \code{TSdescription} and \code{TSdoc}.

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(10),10,1), start=c(1990,1), frequency=1)
 TSreplace(z, serIDs="Series1", con) 
 zz <- TSget("Series1", con)
 TSreplace(z, serIDs="Series1", con, 
     TSdescription="short rnorm series", 
     TSdoc="Series created as an example in the vignette.")
 zz <- TSget("Series1", con, TSdescription=TRUE, TSdoc=TRUE)
 start(zz)
 end(zz)
 TSdescription(zz)
 TSdoc(zz)

 TSdescription("Series1", con)
 TSdoc("Series1", con)

 z <- ts(rnorm(10), start=c(1990,1), frequency=1)
 seriesNames(z) <- "vec"
 TSreplace(z, con)
 zz <- TSget("vec", con)

 z <- ts(matrix(rnorm(20),10,2), start=c(1990,1), frequency=1)
 seriesNames(z) <- c("matc1", "matc2")
 TSreplace(z, con) 
 tfplot(z+1, TSget(c("matc1","matc2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))

\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(20),10,2), start=c(1990,1), frequency=4)
 seriesNames(z) <- c("matc1", "matc2")
 TSreplace(z, con)
 tfplot(z+1, TSget(c("matc1","matc2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))

\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(200),100,2), start=c(1995,1), frequency=12)
 seriesNames(z) <- c("mat2c1", "mat2c2")
 TSreplace(z, con) 
 tfplot(z+1, TSget(c("mat2c1","mat2c2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}

The following examples use dates and times which are not handled by \code{ts},
so the \pkg{zoo} time representation is used.

\begin{Scode}{results=verbatim,fig=TRUE}
require("zoo") 

 z <- zoo(matrix(rnorm(200),100,2), as.Date("1990-01-01") + 0:99)
  seriesNames(z) <- c("zooc1", "zooc2")
 TSreplace(z, con, Table="D")
 tfplot(z+1, TSget(c("zooc1","zooc2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))
  
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- zoo(matrix(rnorm(200),100,2), as.Date("1990-01-01") + 0:99 * 7)
  seriesNames(z) <- c("zooWc1", "zooWc2")
 TSreplace(z, con, Table="W")
 tfplot(z+1, TSget(c("zooWc1","zooWc2"), con), col=c("black", "red"),
    lty=c("dashed", "solid"))  
\end{Scode}

\begin{Scode}{results=hide}
 dbDisconnect(con)
\end{Scode}

\section{Examples Using Web Data}

This section illustrates fetching data from a web server and loading it into the
database. This would be a very slow way to load a database, but provides
examples of different kinds of time series data. The fetching is done with 
\pkg{TShistQuote} which provides a wrapper for \code{get.hist.quote} from 
package \pkg{tseries} to give syntax consistent with the \pkg{TSdbi}.

Fetching data may fail due to lack of an Interenet connection or delays. 

First establish a connection to the database where data will be saved:
\begin{Scode}
con <-  if ("" == user) TSconnect("MySQL", dbname="test") else
    TSconnect("MySQL", dbname="test", username=user, password=passwd, host=host)
\end{Scode}

Now connect to the web server and fetch data:

\begin{Scode}{results=verbatim}
  require("TShistQuote")
  Yahoo <- TSconnect("histQuote", dbname="yahoo") 
  x <- TSget("^gspc", quote = "Close", con=Yahoo)
  plot(x)
  tfplot(x)

  TSrefperiod(x) 
  TSdescription(x) 
  TSdoc(x) 
  TSlabel(x) 
\end{Scode}

Then write the data to the local server, specifying table B for business day 
data (using TSreplace in case the series
is already there from running this example previously):

\begin{Scode}{results=verbatim}
   TSreplace(x,  serIDs="gspc", Table="B", con=con)
\end{Scode}

and check the saved version:

\begin{Scode}{results=verbatim,fig=TRUE}
  TSrefperiod(TSget(serIDs="gspc", con=con)) 
  TSdescription("gspc", con=con) 
  TSdoc("gspc", con=con)
  TSlabel("gspc", con=con) # this is not yet supported on the db
  tfplot(TSget(serIDs="gspc", con=con))
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
   x <- TSget("ibm", quote = c("Close", "Vol"), con=Yahoo)
   TSreplace(x, serIDs=c("ibm.Cl", "ibm.Vol"),  con=con, Table="B",
              TSdescription.=c("IBM Close","IBM  Volume"),
	      TSdoc.= paste(c(
	         "IBM  Close   retrieved on ",
		 "IBM  Volume retrieved  on "), Sys.Date()))

   z <- TSget(serIDs=c("ibm.Cl", "ibm.Vol"), 
             TSdescription=TRUE, TSdoc=TRUE, con=con)
   TSdescription(z)
   TSdoc(z)
   tfplot(z, xlab = TSdoc(z), Title = TSdescription(z))
   tfplot(z, Title="IBM", start="2007-01-01")
\end{Scode}

Oanda has maximum of 500 days, so the start date is specified here so as to
not exceed that.

\begin{Scode}{results=verbatim}
   Oanda <- TSconnect("histQuote", dbname="oanda") 
   x <- TSget("EUR/USD", start=Sys.Date() - 495, con=Oanda)
   TSreplace(x, serIDs="EUR/USD", Table="D", con=con)
\end{Scode}

Then check the saved version:

\begin{Scode}{results=verbatim,fig=TRUE}
   z <- TSget(serIDs="EUR/USD",TSlabel=TRUE, TSdescription=TRUE,  con=con)
   tfplot(z, Title = TSdescription(z), ylab=TSlabel(z))
   tfplot(z, Title = "EUR/USD", start="2007-01-01")
   tfplot(z, Title = "EUR/USD", start="2007-03-01")
   tfplot(z, Title = "EUR/USD", start=Sys.Date()-14, end=Sys.Date(),
      xlab = format(Sys.Date(), "%Y"))
\end{Scode}

\begin{Scode}{results=hide}
  dbDisconnect(con)
  dbDisconnect(Yahoo)
  dbDisconnect(Oanda)
\end{Scode}


\subsection{Examples  Using TSdbi with ets}

These examples use a database called "ets" which is available at the Bank
of Canada.
This set of examples illustrates how the programs might be used if a larger
database is available. Typically a large database would be installed using
database scripts directly rather than from R with \code{TSput} or
\code{TSreplace}. 

The following are wrapped in \code{if (!inherits(conets, "try-error"))} so that
the vignette will build even when the database is not available. This seems to
require an explicit call to \code{print()}, but that is not usually needed to
display results below. Another artifact of this is that results printed in the
if block do not display until the end of the block.

\begin{Scode}{results=verbatim,fig=TRUE}
  m <- dbDriver("MySQL")
  conets <-  try(if ("" == user) TSconnect(m, dbname="ets") else
    TSconnect(m, dbname="ets", username=user, password=passwd, host=host))
  if (!inherits(conets, "try-error")) {
  
  options(TSconnection=conets)

  print(TSmeta("M.SDR.CCUSMA02.ST"))

  EXCH.IDs <- t(matrix(c(
 	"M.SDR.CCUSMA02.ST",	 "SDR/USD exchange rate",
 	"M.CAN.CCUSMA02.ST",	 "CAN/USD exchange rate",
 	"M.MEX.CCUSMA02.ST",	 "MEX/USD exchange rate",
 	"M.JPN.CCUSMA02.ST",	 "JPN/USD exchange rate",
 	"M.EMU.CCUSMA02.ST",	 "Euro/USD exchange rate",
 	"M.OTO.CCUSMA02.ST",	 "OECD /USD exchange rate",
 	"M.G7M.CCUSMA02.ST",	 "G7   /USD exchange rate",
 	"M.E15.CCUSMA02.ST",	 "Euro 15. /USD exchange rate"
	), 2, 8))

  print(TSdates(EXCH.IDs[,1]))
  z <- TSdates(EXCH.IDs[,1])
  print(start(z))
  print(end(z))
   
  tfplot(TSget(serIDs="V122646", conets))
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  print(TSdescription(TSget("V122646", TSdescription=TRUE)))
  print(TSdescription("V122646"))

  print(TSdoc(TSget("V122646", TSdoc=TRUE)))
  print(TSdoc("V122646"))

  tfplot(TSget("V122646", names="V122646", conets))
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  z <- TSget("V122646", TSdescription=TRUE)
  tfplot(z, Title=strsplit(TSdescription(z), ","))
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  z <- TSget("SDSP500", TSdescription=TRUE)
  tfplot(z, Title=TSdescription(z))
  plot(z)
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  z <- TSget(c("DSP500","SDSP500"), TSdescription=TRUE)
  tfplot(z, xlab=TSdescription(z))
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  plot(z)
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  ETSgdp    <- annualizedGrowth(aggregate(TSget("V1992067"),
                   nfrequency=4,FUN=mean), lag=4, names="GDP Y/Y Growth")
  tfplot(ETSgdp)
  }  # end if !try-error
\end{Scode}
  
\begin{Scode}{results=hide}
  if (!inherits(conets, "try-error")) {
  #dbDisconnect(conets)
  dbDisconnect(options()$TSconnection)
  options(TSconnection=NULL)
  }  # end if !try-error
\end{Scode}

\section{Examples Using DBI and direct SQL Queries}

The following examples are queries using the underlying "DBI" functions.
They should not often be needed to access time series, but may be useful
to get at more detailed information, or formulate special queries.

\begin{Scode}{results=hide}
 m <- dbDriver("MySQL")
 con <-  if ("" == user) TSconnect(m, dbname="test") else
    TSconnect(m, dbname="test", username=user, password=passwd, host=host)
 options(TSconnection=con)
\end{Scode}


\begin{Scode}{results=verbatim}
dbListTables(con)
\end{Scode}


This is Mysql specific. Below is a generic sql way to do this.
 
\begin{Scode}{results=verbatim}
 dbGetQuery(con, "show tables;")
 dbGetQuery(con, "describe A;")
 dbGetQuery(con, "describe B;")
 dbGetQuery(con, "describe D;")
 dbGetQuery(con, "describe M;")
 dbGetQuery(con, "describe Meta;")
 dbGetQuery(con, "describe U;")
 dbGetQuery(con, "describe Q;")
 dbGetQuery(con, "describe S;")
 dbGetQuery(con, "describe W;")
\end{Scode}

If schema queries  are supported then the above can be done in a
generic SQL way, but on some systems this will fail because users
do not have read priveleges on the INFORMATION\_SCHEMA table,
so the following are wrapped in \code{try()}.
(SQLite does not seem to support this at all.)

\begin{Scode}{results=verbatim}
z <-  try( dbGetQuery(con, paste(
       "SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.Columns ",
       " WHERE TABLE_SCHEMA='test' AND table_name='A' ;"))  )
if (!inherits( z, "try-error")) print(z)

z <-  try( dbGetQuery(con, paste(
       "SELECT COLUMN_NAME, COLUMN_DEFAULT, COLLATION_NAME, DATA_TYPE,",
       "CHARACTER_SET_NAME, CHARACTER_MAXIMUM_LENGTH, NUMERIC_PRECISION",
 "FROM INFORMATION_SCHEMA.Columns WHERE TABLE_SCHEMA='test' AND table_name='A' ;"))  )
if (!inherits( z, "try-error")) print(z)

z <-  try( dbGetQuery(con, paste(
   "SELECT COLUMN_NAME, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH, NUMERIC_PRECISION",
 "FROM INFORMATION_SCHEMA.Columns WHERE TABLE_SCHEMA='test' AND table_name='M';"))  )
if (!inherits( z, "try-error")) print(z)

\end{Scode}

Finally, to disconnect gracefully, one should

\begin{Scode}{results=hide}

dbDisconnect(con)

dbDisconnect(options()$TSconnection)
options(TSconnection=NULL)
#dbUnloadDriver(m)

FROM TSodbc


The ODBC  user, password, hostname, etc, should be set in ODBC client
configuration file (~/.odbc.ini on Linux/Unix systems) before starting R. 
An example of this file is provided in the final section of this vignette.
Alternatively, this information can be set with
environment variables  ODBC\_USER and ODBC\_PASSWD. The variable ODBC\_HOST
does not seem to work for passing the ODBC connection, so a properly setup
ODBC configuration file is also needed, but the 
environment variables will override the  user and passwd setting in that file.
(An environment variable ODBC\_DATABASE can also be set, but ''test'' is
specified below.) Below, the environment variable  ODBC\_USER is used to
determine which of these methods is being used. If this environment variable is
empty then it is assumed the configuration file will be used.

\begin{Scode}
   user    <- Sys.getenv("ODBC_USER")
   if ("" != user) {
       passwd  <- Sys.getenv("ODBC_PASSWD")
       if ("" == passwd)   passwd <- NULL
      }
\end{Scode}


The next small section of code is necessary to setup database tables that are
used in the examples below. It
needs to be done only once for a database and might typically be done by
an administrator setting up the database, rather than by an end user. 

\begin{Scode}{results=hide}
m <- dbDriver("ODBC")
con <-  if ("" == user) odbcConnect(dsn="test") else
    odbcConnect(dsn="test", uid=user, pwd=passwd)
if(con == -1) stop("error establishing ODBC connection.") 
source(system.file("TSsql/CreateTables.TSsql", package = "TSdbi"))
odbcClose(channel=con)
\end{Scode}

More detailed description of the
instructions for building the database tables is given in the vignette 
for the \pkg{TSdbi} package. Those instruction show how to build the database
using database utilites rather than R, which might be the way a
system administrator would build the database.

\section{Using the Database - TSdbi Functions}

This section gives several simple examples of putting series on and reading them
from the database. (If a large number of series are to be loaded into a database,
one would typically do this with a batch process using the database program's
utilities for loading data.)
The first thing to do is to establish a connection to the database:

\begin{Scode}{results=hide}
 m <- dbDriver("ODBC")
 con <-  if ("" == user) TSconnect(m, dbname="test") else
    TSconnect(m, dbname="test", uid=user, pwd=passwd)
\end{Scode}

\code{TSconnect} uses \code{odbcConnect} from the \pkg{RODBC} package, but checks that the
database has expected tables, and checks for additional features. (It cannot
be used before the tables are created, as done in the previous section.)

This puts a series called \code{vec}  on the database and then reads is back
 
\begin{Scode}
 z <- ts(rnorm(10), start=c(1990,1), frequency=1)
 seriesNames(z) <- "vec"
 if(TSexists("vec", con)) TSdelete("vec", con) 
 TSput( z, con)
 z <- TSget("vec", con)
\end{Scode}
If the series is printed it is seen to be a "ts" time series with some extra
attributes.

\code{TSput} fails if the series already exists on the \code{con}, 
so the above example checks and deletes the series if it already exists. 
\code{TSreplace} does not fail if the series does
not yet exist, so examples below use it instead. Several plots below show
original data and the data retrieved after it is written to the database. One is
added to the original data so that both lines are visible.

And now more examples:

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(20),10,2), start=c(1990,1), frequency=1)
 seriesNames(z) <- c("matc1", "matc2")
 TSreplace(z, con)
 TSget("matc1", con)
 TSget("matc2", con)
 TSget(c("matc1","matc2"), con)
 require("tfplot")
 tfplot(z+1, TSget(c("matc1","matc2"), con), 
          lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(20),10,2), start=c(1990,1), frequency=4)
  seriesNames(z) <- c("matc1", "matc2")
 TSreplace(z, con)
 TSget(c("matc1","matc2"), con)
 tfplot(z+1, TSget(c("matc1","matc2"), con),
          lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(200),100,2), start=c(1995,1), frequency=12)
  seriesNames(z) <- c("mat2c1", "mat2c2")
 TSreplace(z, con)
 tfplot(z+1, TSget(c("mat2c1","mat2c2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}
 
The following extract information about the series from the database, although
not much information has been added for these examples. 
\begin{Scode}
 TSmeta("mat2c1", con)
 TSmeta("vec", con)
 TSdates("vec", con)
 TSdescription("vec", con)
 TSdoc("vec", con)
\end{Scode}

Below are exampoles that make more use of \code{TSdescription} and code{TSdoc}.

Often it is convenient to set the default connection:

\begin{Scode}
 options(TSconnection=con)
\end{Scode}
and then the \code{con} specification can be omitted from the function calls
unless another connection is needed. The \code{con} can still be specified, and
some examples below do specify it, just to illustrate the alternative syntax.

\begin{Scode}{results=verbatim}
 z <- TSget("mat2c1") 
 TSmeta("mat2c1")
\end{Scode}


Data documentation can be in two forms, a description specified by 
\code{TSdescription}
or longer documentation specified by \code{TSdoc}. These can be added to the time
series object, in which case they will be written to the database when
\code{TSput} or \code{TSreplace} is used to put the series on the database. 
Alternatively, they
can be specified as arguments to \code{TSput} or \code{TSreplace}.
The description or documentation will be retrieved as part of the series object
with \code{TSget} only if this is specified with the logical arguments
\code{TSdescription} and \code{TSdoc}. They can also be retrieved directly from the
database with the functions \code{TSdescription} and \code{TSdoc}.

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(10),10,1), start=c(1990,1), frequency=1)
 TSreplace(z, serIDs="Series1", con) 
 zz <- TSget("Series1", con)
 TSreplace(z, serIDs="Series1", con, 
     TSdescription="short rnorm series", 
     TSdoc="Series created as an example in the vignette.")
 zz <- TSget("Series1", con, TSdescription=TRUE, TSdoc=TRUE)
 start(zz)
 end(zz)
 TSdescription(zz)
 TSdoc(zz)

 TSdescription("Series1", con)
 TSdoc("Series1", con)

 z <- ts(rnorm(10), start=c(1990,1), frequency=1)
 seriesNames(z) <- "vec"
 TSreplace(z, con)
 zz <- TSget("vec", con)

 z <- ts(matrix(rnorm(20),10,2), start=c(1990,1), frequency=1)
 seriesNames(z) <- c("matc1", "matc2")
 TSreplace(z, con) 
 tfplot(z+1, TSget(c("matc1","matc2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))

\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(20),10,2), start=c(1990,1), frequency=4)
 seriesNames(z) <- c("matc1", "matc2")
 TSreplace(z, con)
 tfplot(z+1, TSget(c("matc1","matc2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))

\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(200),100,2), start=c(1995,1), frequency=12)
 seriesNames(z) <- c("mat2c1", "mat2c2")
 TSreplace(z, con) 
 tfplot(z+1, TSget(c("mat2c1","mat2c2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}

The following examples use dates and times which are not handled by \code{ts},
so the \pkg{zoo} time representation is used.

\begin{Scode}{results=verbatim,fig=TRUE}
require("zoo") 

 z <- zoo(matrix(rnorm(200),100,2), as.Date("1990-01-01") + 0:99)
  seriesNames(z) <- c("zooc1", "zooc2")
 TSreplace(z, con, Table="D")
 tfplot(z+1, TSget(c("zooc1","zooc2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))
  
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- zoo(matrix(rnorm(200),100,2), as.Date("1990-01-01") + 0:99 * 7)
  seriesNames(z) <- c("zooWc1", "zooWc2")
 TSreplace(z, con, Table="W")
 tfplot(z+1, TSget(c("zooWc1","zooWc2"), con), col=c("black", "red"),
    lty=c("dashed", "solid"))  
\end{Scode}

\begin{Scode}{results=hide}
 dbDisconnect(con)
 #dbUnloadDriver(m)
\end{Scode}

\section{Examples Using Web Data}

This section illustrates fetching data from a web server and loading it into the
database. This would be a very slow way to load a database, but provides
examples of different kinds of time series data. The fetching is done with 
\pkg{TShistQuote} which provides a wrapper for \code{get.hist.quote} from 
package \pkg{tseries} to give syntax consistent with the \pkg{TSdbi}.

Fetching data may fail due to lack of an Interenet connection or delays. 

First establish a connection to the database where data will be saved:
\begin{Scode}
  con <-  if ("" == user) TSconnect("ODBC", dbname="test") else
    TSconnect("ODBC", dbname="test", uid=user, pwd=passwd)
\end{Scode}

Now connect to the web server and fetch data:

\begin{Scode}{results=verbatim}
  require("TShistQuote")
  Yahoo <- TSconnect("histQuote", dbname="yahoo") 
  x <- TSget("^gspc", quote = "Close", con=Yahoo)
  plot(x)
  tfplot(x)

  TSrefperiod(x) 
  TSdescription(x) 
  TSdoc(x) 
  TSlabel(x) 
\end{Scode}

Then write the data to the local server, specifying table B for business day 
data (using TSreplace in case the series
is already there from running this example previously):

\begin{Scode}{results=verbatim}
   TSreplace(x,  serIDs="gspc", Table="B", con=con)
\end{Scode}

and check the saved version:

\begin{Scode}{results=verbatim,fig=TRUE}
  TSrefperiod(TSget(serIDs="gspc", con=con)) 
  TSdescription("gspc", con=con) 
  TSdoc("gspc", con=con)
  TSlabel("gspc", con=con) # this is not yet supported on the db
  tfplot(TSget(serIDs="gspc", con=con))
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
   x <- TSget("ibm", quote = c("Close", "Vol"), con=Yahoo)
   TSreplace(x, serIDs=c("ibm.Cl", "ibm.Vol"),  con=con, Table="B",
              TSdescription.=c("IBM Close","IBM  Volume"),
	      TSdoc.= paste(c(
	         "IBM  Close   retrieved on ",
		 "IBM  Volume retrieved  on "), Sys.Date()))

   z <- TSget(serIDs=c("ibm.Cl", "ibm.Vol"), 
             TSdescription=TRUE, TSdoc=TRUE, con=con)
   TSdescription(z)
   TSdoc(z)
   tfplot(z, xlab = TSdoc(z), Title = TSdescription(z))
   tfplot(z, Title="IBM", start="2007-01-01")
\end{Scode}

Oanda has maximum of 500 days, so the start date is specified here so as to
not exceed that.

\begin{Scode}{results=verbatim}
   Oanda <- TSconnect("histQuote", dbname="oanda") 
   x <- TSget("EUR/USD", start=Sys.Date() - 495, con=Oanda)
   TSreplace(x, serIDs="EUR/USD", Table="D", con=con)
\end{Scode}

Then check the saved version:

\begin{Scode}{results=verbatim,fig=TRUE}
   z <- TSget(serIDs="EUR/USD",TSlabel=TRUE, TSdescription=TRUE,  con=con)
   tfplot(z, Title = TSdescription(z), ylab=TSlabel(z))
   tfplot(z, Title = "EUR/USD", start=Sys.Date() - 495)
   tfplot(z, Title = "EUR/USD", start=Sys.Date() - 100)
   tfplot(z, Title = "EUR/USD", start=Sys.Date()  -14, end=Sys.Date(),
      xlab = format(Sys.Date(), "%Y"))
\end{Scode}

\begin{Scode}{results=hide}
  dbDisconnect(con)
  dbDisconnect(Yahoo)
  dbDisconnect(Oanda)
\end{Scode}

\subsection{Examples Using TSdbi with ets}

A more complete set of examples will be available as a vignette in a package
tentatively called \code{TSdata}. This should include examples from a more
extensive database of economic time series.

\section{Examples Using DBI and direct SQL Queries}

The following examples are queries using direct SQL queries. 
They should not often be needed to access time series, but may be useful
to get at more detailed information, or formulate special queries. Some
databases support special calls to access database or table information, but the
following try to use generic SQL.

\begin{Scode}{results=hide}
 m <- dbDriver("ODBC")
 con <-  if ("" == user) TSconnect(m, dbname="test") else
    TSconnect(m, dbname="test", uid=user, pwd=passwd)
 options(TSconnection=con)
\end{Scode}


\begin{Scode}{results=verbatim}
dbListTables(con)
\end{Scode}


If schema queries  are supported then table information can be obtained in a
generic SQL way, but on some systems this will fail because users
do not have read priveleges on the INFORMATION\_SCHEMA table,
so the following are wrapped in \code{tryCatch()}.
(SQLite does not seem to support this at all.)

\begin{Scode}{results=verbatim}
  tryCatch( dbGetQuery(con, paste(
       "SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.Columns ",
       " WHERE TABLE_SCHEMA='test' AND table_name='A' ;"))  )

  tryCatch( dbGetQuery(con, paste(
       "SELECT COLUMN_NAME, COLUMN_DEFAULT, COLLATION_NAME, DATA_TYPE,",
       "CHARACTER_SET_NAME, CHARACTER_MAXIMUM_LENGTH, NUMERIC_PRECISION",
 "FROM INFORMATION_SCHEMA.Columns WHERE TABLE_SCHEMA='test' AND table_name='A' ;"))  )

  tryCatch( dbGetQuery(con, paste(
   "SELECT COLUMN_NAME, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH, NUMERIC_PRECISION",
 "FROM INFORMATION_SCHEMA.Columns WHERE TABLE_SCHEMA='test' AND table_name='M';"))  )

\end{Scode}

Finally, to disconnect gracefully, one should

\begin{Scode}{results=hide}
  dbDisconnect(con)
  #dbDisconnect(options()$TSconnection)
  options(TSconnection=NULL)
  odbcCloseAll()
  dbUnloadDriver(m)
\end{Scode}

\section{Example  ODBC configuration file}

Following is an example ODBC configuration file I use in Linux (so the file is
in my home directory and called  ''.odbc.ini'') to connect to a remote
PostgreSQL server:

\begin{verbatim}
[test]

Description             = test DB (Postgresql)
Driver                  = Postgresql
Trace                   = No
TraceFile               = /tmp/test_odbc.log
Database                = test
Servername              = some.host
UserName                = paul
Password                = mySecret
Port                    = 5432
Protocol                = 6.4
ReadOnly                = No
RowVersioning           = No
ShowSystemTables        = No
ShowOidColumn           = No
FakeOidIndex            = No
ConnSettings            =


[ets]

Description             = ets DB (Postgresql)
Driver                  = Postgresql
Trace                   = No
TraceFile               = /tmp/test_odbc.log
Database                = ets
Servername              = some.host
UserName                = paul
Password                = mySecret
Port                    = 5432
Protocol                = 6.4
ReadOnly                = No
RowVersioning           = No
ShowSystemTables        = No
ShowOidColumn           = No
FakeOidIndex            = No
ConnSettings            =
\end{verbatim}

\end{Scode}

FROM TSOracle


The Oracle  user, password, and hostname should be set in Oracle client
configuration file
(.my.cnf) before starting R. Alternatively, this information can be set with
environment variables  ORACLE\_USER, ORACLE\_PASSWD and ORACLE\_HOST.
(An environment variable ORACLE\_DATABASE can also be set, but ''test'' is
specified below.) Below, the environment variable  ORACLE\_USER is used to
determine which of these methods is being used. If this environment variable is
empty then it is assumed the configuration file will be used.

\begin{Scode}
   user    <- Sys.getenv("ORACLE_USER")
   if ("" != user) {
       host    <- Sys.getenv("ORACLE_HOST")
       if ("" == host)     host <- Sys.info()["nodename"] 
       passwd  <- Sys.getenv("ORACLE_PASSWD")
       if ("" == passwd)   passwd <- NULL
      }
\end{Scode}

The next small section of code is necessary to setup database tables that are
used in the examples below. It
needs to be done only once for a database and might typically be done by
an administrator setting up the database, rather than by an end user. 

\begin{Scode}{results=hide}
m <- dbDriver("Oracle")
con <-  if ("" == user) dbConnect(m, dbname="test") else
    dbConnect(m, dbname="test", username=user, password=passwd, host=host)

source(system.file("TSsql/CreateTables.TSsql", package = "TSdbi"))
dbDisconnect(con)
\end{Scode}

More detailed description of the
instructions for building the database tables is given in the vignette 
for the \pkg{TSdbi} package. Those instruction show how to build the database
using database utilites rather than R, which might be the way a
system administrator would build the database.

\section{Using the Database - TSdbi Functions}

This section gives several simple examples of putting series on and reading them
from the database. (If a large number of series are to be loaded into a database,
one would typically do this with a batch process using the database program's
utilities for loading data.)
The first thing to do is to establish a connection to the database:

\begin{Scode}{results=hide}
con <-  if ("" == user) TSconnect("Oracle", dbname="test") else
    TSconnect("Oracle", dbname="test", username=user, password=passwd, host=host)
\end{Scode}

\code{TSconnect} uses \code{dbConnect} from the \pkg{DBI} package, but checks that the
database has expected tables, and checks for additional features. (It cannot
be used before the tables are created, as done in the previous section.)

This puts a series called \code{vec}  on the database and then reads is back
 
\begin{Scode}
 z <- ts(rnorm(10), start=c(1990,1), frequency=1)
 seriesNames(z) <- "vec"
 if(TSexists("vec", con)) TSdelete("vec", con) 
 TSput( z, con)
 z <- TSget("vec", con)
\end{Scode}
If the series is printed it is seen to be a "ts" time series with some extra
attributes.

\code{TSput} fails if the series already exists on the \code{con}, 
so the above example checks and deletes the series if it already exists. 
\code{TSreplace} does not fail if the series does
not yet exist, so examples below use it instead. Several plots below show
original data and the data retrieved after it is written to the database. One is
added to the original data so that both lines are visible.

And now more examples:

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(20),10,2), start=c(1990,1), frequency=1)
 seriesNames(z) <- c("matc1", "matc2")
 TSreplace(z, con)
 TSget("matc1", con)
 TSget("matc2", con)
 TSget(c("matc1","matc2"), con)
 require("tfplot")
 tfplot(z+1, TSget(c("matc1","matc2"), con), 
          lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(20),10,2), start=c(1990,1), frequency=4)
  seriesNames(z) <- c("matc1", "matc2")
 TSreplace(z, con)
 TSget(c("matc1","matc2"), con)
 tfplot(z+1, TSget(c("matc1","matc2"), con),
          lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(200),100,2), start=c(1995,1), frequency=12)
  seriesNames(z) <- c("mat2c1", "mat2c2")
 TSreplace(z, con)
 tfplot(z+1, TSget(c("mat2c1","mat2c2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}
 
The following extract information about the series from the database, although
not much information has been added for these examples. 
\begin{Scode}
 TSmeta("mat2c1", con)
 TSmeta("vec", con)
 TSdates("vec", con)
 TSdescription("vec", con)
 TSdoc("vec", con)
\end{Scode}

Below are exampoles that make more use of \code{TSdescription} and code{TSdoc}.

Often it is convenient to set the default connection:

\begin{Scode}
 options(TSconnection=con)
\end{Scode}
and then the \code{con} specification can be omitted from the function calls
unless another connection is needed. The \code{con} can still be specified, and
some examples below do specify it, just to illustrate the alternative syntax.

\begin{Scode}{results=verbatim}
 z <- TSget("mat2c1") 
 TSmeta("mat2c1")
\end{Scode}


Data documentation can be in two forms, a description specified by 
\code{TSdescription}
or longer documentation specified by \code{TSdoc}. These can be added to the time
series object, in which case they will be written to the database when
\code{TSput} or \code{TSreplace} is used to put the series on the database. 
Alternatively, they
can be specified as arguments to \code{TSput} or \code{TSreplace}.
The description or documentation will be retrieved as part of the series object
with \code{TSget} only if this is specified with the logical arguments
\code{TSdescription} and \code{TSdoc}. They can also be retrieved directly from the
database with the functions \code{TSdescription} and \code{TSdoc}.

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(10),10,1), start=c(1990,1), frequency=1)
 TSreplace(z, serIDs="Series1", con) 
 zz <- TSget("Series1", con)
 TSreplace(z, serIDs="Series1", con, 
     TSdescription="short rnorm series", 
     TSdoc="Series created as an example in the vignette.")
 zz <- TSget("Series1", con, TSdescription=TRUE, TSdoc=TRUE)
 start(zz)
 end(zz)
 TSdescription(zz)
 TSdoc(zz)

 TSdescription("Series1", con)
 TSdoc("Series1", con)

 z <- ts(rnorm(10), start=c(1990,1), frequency=1)
 seriesNames(z) <- "vec"
 TSreplace(z, con)
 zz <- TSget("vec", con)

 z <- ts(matrix(rnorm(20),10,2), start=c(1990,1), frequency=1)
 seriesNames(z) <- c("matc1", "matc2")
 TSreplace(z, con) 
 tfplot(z+1, TSget(c("matc1","matc2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))

\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(20),10,2), start=c(1990,1), frequency=4)
 seriesNames(z) <- c("matc1", "matc2")
 TSreplace(z, con)
 tfplot(z+1, TSget(c("matc1","matc2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))

\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(200),100,2), start=c(1995,1), frequency=12)
 seriesNames(z) <- c("mat2c1", "mat2c2")
 TSreplace(z, con) 
 tfplot(z+1, TSget(c("mat2c1","mat2c2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}

The following examples use dates and times which are not handled by \code{ts},
so the \pkg{zoo} time representation is used.

\begin{Scode}{results=verbatim,fig=TRUE}
require("zoo") 

 z <- zoo(matrix(rnorm(200),100,2), as.Date("1990-01-01") + 0:99)
  seriesNames(z) <- c("zooc1", "zooc2")
 TSreplace(z, con, Table="D")
 tfplot(z+1, TSget(c("zooc1","zooc2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))
  
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- zoo(matrix(rnorm(200),100,2), as.Date("1990-01-01") + 0:99 * 7)
  seriesNames(z) <- c("zooWc1", "zooWc2")
 TSreplace(z, con, Table="W")
 tfplot(z+1, TSget(c("zooWc1","zooWc2"), con), col=c("black", "red"),
    lty=c("dashed", "solid"))  
\end{Scode}

\begin{Scode}{results=hide}
 dbDisconnect(con)
\end{Scode}

\section{Examples Using Web Data}

This section illustrates fetching data from a web server and loading it into the
database. This would be a very slow way to load a database, but provides
examples of different kinds of time series data. The fetching is done with 
\pkg{TShistQuote} which provides a wrapper for \code{get.hist.quote} from 
package \pkg{tseries} to give syntax consistent with the \pkg{TSdbi}.

Fetching data may fail due to lack of an Interenet connection or delays. 

First establish a connection to the database where data will be saved:
\begin{Scode}
con <-  if ("" == user) TSconnect("Oracle", dbname="test") else
    TSconnect("Oracle", dbname="test", username=user, password=passwd, host=host)
\end{Scode}

Now connect to the web server and fetch data:

\begin{Scode}{results=verbatim}
  require("TShistQuote")
  Yahoo <- TSconnect("histQuote", dbname="yahoo") 
  x <- TSget("^gspc", quote = "Close", con=Yahoo)
  plot(x)
  tfplot(x)

  TSrefperiod(x) 
  TSdescription(x) 
  TSdoc(x) 
  TSlabel(x) 
\end{Scode}

Then write the data to the local server, specifying table B for business day 
data (using TSreplace in case the series
is already there from running this example previously):

\begin{Scode}{results=verbatim}
   TSreplace(x,  serIDs="gspc", Table="B", con=con)
\end{Scode}

and check the saved version:

\begin{Scode}{results=verbatim,fig=TRUE}
  TSrefperiod(TSget(serIDs="gspc", con=con)) 
  TSdescription("gspc", con=con) 
  TSdoc("gspc", con=con)
  TSlabel("gspc", con=con) # this is not yet supported on the db
  tfplot(TSget(serIDs="gspc", con=con))
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
   x <- TSget("ibm", quote = c("Close", "Vol"), con=Yahoo)
   TSreplace(x, serIDs=c("ibm.Cl", "ibm.Vol"),  con=con, Table="B",
              TSdescription.=c("IBM Close","IBM  Volume"),
	      TSdoc.= paste(c(
	         "IBM  Close   retrieved on ",
		 "IBM  Volume retrieved  on "), Sys.Date()))

   z <- TSget(serIDs=c("ibm.Cl", "ibm.Vol"), 
             TSdescription=TRUE, TSdoc=TRUE, con=con)
   TSdescription(z)
   TSdoc(z)
   tfplot(z, xlab = TSdoc(z), Title = TSdescription(z))
   tfplot(z, Title="IBM", start="2007-01-01")
\end{Scode}

Oanda has maximum of 500 days, so the start date is specified here so as to
not exceed that.

\begin{Scode}{results=verbatim}
   Oanda <- TSconnect("histQuote", dbname="oanda") 
   x <- TSget("EUR/USD", start=Sys.Date() - 495, con=Oanda)
   TSreplace(x, serIDs="EUR/USD", Table="D", con=con)
\end{Scode}

Then check the saved version:

\begin{Scode}{results=verbatim,fig=TRUE}
   z <- TSget(serIDs="EUR/USD",TSlabel=TRUE, TSdescription=TRUE,  con=con)
   tfplot(z, Title = TSdescription(z), ylab=TSlabel(z))
   tfplot(z, Title = "EUR/USD", start="2007-01-01")
   tfplot(z, Title = "EUR/USD", start="2007-03-01")
   tfplot(z, Title = "EUR/USD", start=Sys.Date()-14, end=Sys.Date(),
      xlab = format(Sys.Date(), "%Y"))
\end{Scode}

\begin{Scode}{results=hide}
  dbDisconnect(con)
  dbDisconnect(Yahoo)
  dbDisconnect(Oanda)
\end{Scode}


\subsection{Examples  Using TSdbi with ets}

These examples use a database called "ets" which is available at the Bank
of Canada.
This set of examples illustrates how the programs might be used if a larger
database is available. Typically a large database would be installed using
database scripts directly rather than from R with \code{TSput} or
\code{TSreplace}. 

The following are wrapped in \code{if (!inherits(conets, "try-error"))} so that
the vignette will build even when the database is not available. This seems to
require an explicit call to \code{print()}, but that is not usually needed to
display results below. Another artifact of this is that results printed in the
if block do not display until the end of the block.

\begin{Scode}{results=verbatim,fig=TRUE}
  m <- dbDriver("Oracle")
  conets <-  try(if ("" == user) TSconnect(m, dbname="ets") else
    TSconnect(m, dbname="ets", username=user, password=passwd, host=host))
  if (!inherits(conets, "try-error")) {
  
  options(TSconnection=conets)

  print(TSmeta("M.SDR.CCUSMA02.ST"))

  EXCH.IDs <- t(matrix(c(
 	"M.SDR.CCUSMA02.ST",	 "SDR/USD exchange rate",
 	"M.CAN.CCUSMA02.ST",	 "CAN/USD exchange rate",
 	"M.MEX.CCUSMA02.ST",	 "MEX/USD exchange rate",
 	"M.JPN.CCUSMA02.ST",	 "JPN/USD exchange rate",
 	"M.EMU.CCUSMA02.ST",	 "Euro/USD exchange rate",
 	"M.OTO.CCUSMA02.ST",	 "OECD /USD exchange rate",
 	"M.G7M.CCUSMA02.ST",	 "G7   /USD exchange rate",
 	"M.E15.CCUSMA02.ST",	 "Euro 15. /USD exchange rate"
	), 2, 8))

  print(TSdates(EXCH.IDs[,1]))
  z <- TSdates(EXCH.IDs[,1])
  print(start(z))
  print(end(z))
   
  tfplot(TSget(serIDs="V122646", conets))
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  print(TSdescription(TSget("V122646", TSdescription=TRUE)))
  print(TSdescription("V122646"))

  print(TSdoc(TSget("V122646", TSdoc=TRUE)))
  print(TSdoc("V122646"))

  tfplot(TSget("V122646", names="V122646", conets))
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  z <- TSget("V122646", TSdescription=TRUE)
  tfplot(z, Title=strsplit(TSdescription(z), ","))
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  z <- TSget("SDSP500", TSdescription=TRUE)
  tfplot(z, Title=TSdescription(z))
  plot(z)
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  z <- TSget(c("DSP500","SDSP500"), TSdescription=TRUE)
  tfplot(z, xlab=TSdescription(z))
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  plot(z)
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  ETSgdp    <- annualizedGrowth(aggregate(TSget("V1992067"),
                   nfrequency=4,FUN=mean), lag=4, names="GDP Y/Y Growth")
  tfplot(ETSgdp)
  }  # end if !try-error
\end{Scode}
  
\begin{Scode}{results=hide}
  if (!inherits(conets, "try-error")) {
  #dbDisconnect(conets)
  dbDisconnect(options()$TSconnection)
  options(TSconnection=NULL)
  }  # end if !try-error
\end{Scode}

\section{Examples Using DBI and direct SQL Queries}

The following examples are queries using the underlying "DBI" functions.
They should not often be needed to access time series, but may be useful
to get at more detailed information, or formulate special queries.

\begin{Scode}{results=hide}
 m <- dbDriver("Oracle")
 con <-  if ("" == user) TSconnect(m, dbname="test") else
    TSconnect(m, dbname="test", username=user, password=passwd, host=host)
 options(TSconnection=con)
\end{Scode}


\begin{Scode}{results=verbatim}
dbListTables(con)
\end{Scode}


This is Mysql specific. Below is a generic sql way to do this.
 
\begin{Scode}{results=verbatim}
 dbGetQuery(con, "show tables;")
 dbGetQuery(con, "describe A;")
 dbGetQuery(con, "describe B;")
 dbGetQuery(con, "describe D;")
 dbGetQuery(con, "describe M;")
 dbGetQuery(con, "describe Meta;")
 dbGetQuery(con, "describe U;")
 dbGetQuery(con, "describe Q;")
 dbGetQuery(con, "describe S;")
 dbGetQuery(con, "describe W;")
\end{Scode}

If schema queries  are supported then the above can be done in a
generic SQL way, but on some systems this will fail because users
do not have read priveleges on the INFORMATION\_SCHEMA table,
so the following are wrapped in \code{try()}.
(SQLite does not seem to support this at all.)

\begin{Scode}{results=verbatim}
z <-  try( dbGetQuery(con, paste(
       "SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.Columns ",
       " WHERE TABLE_SCHEMA='test' AND table_name='A' ;"))  )
if (!inherits( z, "try-error")) print(z)

z <-  try( dbGetQuery(con, paste(
       "SELECT COLUMN_NAME, COLUMN_DEFAULT, COLLATION_NAME, DATA_TYPE,",
       "CHARACTER_SET_NAME, CHARACTER_MAXIMUM_LENGTH, NUMERIC_PRECISION",
 "FROM INFORMATION_SCHEMA.Columns WHERE TABLE_SCHEMA='test' AND table_name='A' ;"))  )
if (!inherits( z, "try-error")) print(z)

z <-  try( dbGetQuery(con, paste(
   "SELECT COLUMN_NAME, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH, NUMERIC_PRECISION",
 "FROM INFORMATION_SCHEMA.Columns WHERE TABLE_SCHEMA='test' AND table_name='M';"))  )
if (!inherits( z, "try-error")) print(z)

\end{Scode}

Finally, to disconnect gracefully, one should

\begin{Scode}{results=hide}

dbDisconnect(con)

dbDisconnect(options()$TSconnection)
options(TSconnection=NULL)
#dbUnloadDriver(m)
\end{Scode}

FROM TSPostgreSQL


The PostgreSQL  user, and password, should be set in PostgreSQL 
configuration file (.pgpass) before starting R. 
The Postgress documentation suggests that it should be
possible to get the host from the .pgpass file too, but I have not been able
to make that work. The PostgreSQL alternative to the configuration file
is to use environment variables PGDATABASE, PGHOST, PGPORT, and PGUSER.
This package (and CRAN) support another alternatively to set this information 
with environment variables  POSTGRES\_USER, POSTGRES\_PASSWD 
and POSTGRES\_HOST.
(An environment variable POSTGRES\_DATABASE can also be set, but ''test'' is
specified below.)  Below, the environment variable  POSTGRES\_USER is used to
determine how the user and password are set. If this environment variable is
empty then it is assumed the PostgreSQL mechanism will be used (i.e. the driver
consults the PG* variables or the configuration file). However, the host is
determined by the following logic:

\begin{Scode}
   user    <- Sys.getenv("POSTGRES_USER")
   host    <- Sys.getenv("POSTGRES_HOST")
   if ("" == host) host  <- Sys.getenv("PGHOST")
   if ("" == host) host  <- "localhost"  #Sys.info()["nodename"] 
   if ("" != user) passwd  <- Sys.getenv("POSTGRES_PASSWD")
\end{Scode}


The next small section of code is necessary to setup database tables that are
used in the examples below. It
needs to be done only once for a database and might typically be done by
an administrator setting up the database, rather than by an end user. 

\begin{Scode}{results=hide}
m <- dbDriver("PostgreSQL")
con <-  if ("" == user) dbConnect(m, dbname="test", host=host) else
    dbConnect(m, dbname="test", user=user, password=passwd, host=host)

source(system.file("TSsql/CreateTables.TSsql", package = "TSdbi"))
dbDisconnect(con)
\end{Scode}

More detailed description of the
instructions for building the database tables is given in the vignette 
for the \pkg{TSdbi} package. Those instruction show how to build the database
using database utilites rather than R, which might be the way a
system administrator would build the database.

\section{Using the Database - TSdbi Functions}

This section gives several simple examples of putting series on and reading them
from the database. (If a large number of series are to be loaded into a database,
one would typically do this with a batch process using the database program's
utilities for loading data.)
The first thing to do is to establish a connection to the database:

\begin{Scode}{results=hide}
 m <- dbDriver("PostgreSQL")
 con <-  if ("" == user) TSconnect(m, dbname="test", host=host) else
    TSconnect(m, dbname="test", user=user, password=passwd, host=host)
\end{Scode}

\code{TSconnect} uses \code{dbConnect} from the \pkg{DBI} package, but checks that the
database has expected tables, and checks for additional features. (It cannot
be used before the tables are created, as done in the previous section.)

This puts a series called \code{vec}  on the database and then reads is back
 
\begin{Scode}
 z <- ts(rnorm(10), start=c(1990,1), frequency=1)
 seriesNames(z) <- "vec"
 if(TSexists("vec", con)) TSdelete("vec", con) 
 TSput( z, con)
 z <- TSget("vec", con)
\end{Scode}
If the series is printed it is seen to be a "ts" time series with some extra
attributes.

\code{TSput} fails if the series already exists on the \code{con}, 
so the above example checks and deletes the series if it already exists. 
\code{TSreplace} does not fail if the series does
not yet exist, so examples below use it instead. Several plots below show
original data and the data retrieved after it is written to the database. One is
added to the original data so that both lines are visible.

And now more examples:

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(20),10,2), start=c(1990,1), frequency=1)
 seriesNames(z) <- c("matc1", "matc2")
 TSreplace(z, con)
 TSget("matc1", con)
 TSget("matc2", con)
 TSget(c("matc1","matc2"), con)
 require("tfplot")
 tfplot(z+1, TSget(c("matc1","matc2"), con), 
          lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(20),10,2), start=c(1990,1), frequency=4)
  seriesNames(z) <- c("matc1", "matc2")
 TSreplace(z, con)
 TSget(c("matc1","matc2"), con)
 tfplot(z+1, TSget(c("matc1","matc2"), con),
          lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(200),100,2), start=c(1995,1), frequency=12)
  seriesNames(z) <- c("mat2c1", "mat2c2")
 TSreplace(z, con)
 tfplot(z+1, TSget(c("mat2c1","mat2c2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}
 
The following extract information about the series from the database, although
not much information has been added for these examples. 
\begin{Scode}{results=verbatim}
 TSmeta("mat2c1", con)
 TSmeta("vec", con)
 TSdates("vec", con)
 TSdescription("vec", con)
 TSdoc("vec", con)
\end{Scode}
Below are examples that make more use of \code{TSdescription} and code{TSdoc}.

Often it is convenient to set the default connection:
\begin{Scode}
 options(TSconnection=con)
\end{Scode}
and then the \code{con} specification can be omitted from the function calls
unless another connection is needed. The \code{con} can still be specified, and
some examples below do specify it, just to illustrate the alternative syntax.
\begin{Scode}{results=verbatim}
 z <- TSget("mat2c1") 
 TSmeta("mat2c1")
\end{Scode}

Data documentation can be in two forms, a description specified by 
\code{TSdescription}
or longer documentation specified by \code{TSdoc}. These can be added to the time
series object, in which case they will be written to the database when
\code{TSput} or \code{TSreplace} is used to put the series on the database. 
Alternatively, they
can be specified as arguments to \code{TSput} or \code{TSreplace}.
The description or documentation will be retrieved as part of the series object
with \code{TSget} only if this is specified with the logical arguments
\code{TSdescription} and \code{TSdoc}. They can also be retrieved directly from the
database with the functions \code{TSdescription} and \code{TSdoc}.

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(10),10,1), start=c(1990,1), frequency=1)
 TSreplace(z, serIDs="Series1", con) 
 zz <- TSget("Series1", con)
 TSreplace(z, serIDs="Series1", con, 
     TSdescription="short rnorm series", 
     TSdoc="Series created as an example in the vignette.")
 zz <- TSget("Series1", con, TSdescription=TRUE, TSdoc=TRUE)
 start(zz)
 end(zz)
 TSdescription(zz)
 TSdoc(zz)

 TSdescription("Series1", con)
 TSdoc("Series1", con)

 z <- ts(rnorm(10), start=c(1990,1), frequency=1)
 seriesNames(z) <- "vec"
 TSreplace(z, con)
 zz <- TSget("vec", con)

 z <- ts(matrix(rnorm(20),10,2), start=c(1990,1), frequency=1)
 seriesNames(z) <- c("matc1", "matc2")
 TSreplace(z, con) 
 tfplot(z+1, TSget(c("matc1","matc2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))

\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(20),10,2), start=c(1990,1), frequency=4)
 seriesNames(z) <- c("matc1", "matc2")
 TSreplace(z, con)
 tfplot(z+1, TSget(c("matc1","matc2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))

\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(200),100,2), start=c(1995,1), frequency=12)
 seriesNames(z) <- c("mat2c1", "mat2c2")
 TSreplace(z, con) 
 tfplot(z+1, TSget(c("mat2c1","mat2c2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}

The following examples use dates and times which are not handled by \code{ts},
so the \pkg{zoo} time representation is used.

\begin{Scode}{results=verbatim,fig=TRUE}
require("zoo") 

 z <- zoo(matrix(rnorm(200),100,2), as.Date("1990-01-01") + 0:99)
  seriesNames(z) <- c("zooc1", "zooc2")
 TSreplace(z, con, Table="D")
 tfplot(z+1, TSget(c("zooc1","zooc2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))
  
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- zoo(matrix(rnorm(200),100,2), as.Date("1990-01-01") + 0:99 * 7)
  seriesNames(z) <- c("zooWc1", "zooWc2")
 TSreplace(z, con, Table="W")
 tfplot(z+1, TSget(c("zooWc1","zooWc2"), con), col=c("black", "red"),
    lty=c("dashed", "solid"))  
\end{Scode}

\begin{Scode}{results=hide}
 dbDisconnect(con)
 #dbUnloadDriver(m)
\end{Scode}

\section{Examples Using Web Data}

This section illustrates fetching data from a web server and loading it into the
database. This would be a very slow way to load a database, but provides
examples of different kinds of time series data. The fetching is done with 
\pkg{TShistQuote} which provides a wrapper for \code{get.hist.quote} from 
package \pkg{tseries} to give syntax consistent with the \pkg{TSdbi}.

Fetching data may fail due to lack of an Interenet connection or delays. 

First establish a connection to the database where data will be saved:
\begin{Scode}
con <-  if ("" == user) TSconnect("PostgreSQL", dbname="test", host=host) else
    TSconnect("PostgreSQL", dbname="test", user=user, password=passwd, host=host)
\end{Scode}

Now connect to the web server and fetch data:

\begin{Scode}{results=verbatim}
  require("TShistQuote")
  Yahoo <- TSconnect("histQuote", dbname="yahoo") 
  x <- TSget("^gspc", quote = "Close", con=Yahoo)
  plot(x)
  tfplot(x)

  TSrefperiod(x) 
  TSdescription(x) 
  TSdoc(x) 
  TSlabel(x) 
  TSsource(x) 
\end{Scode}

Then write the data to the local server, specifying table B for business day 
data (using TSreplace in case the series
is already there from running this example previously):

\begin{Scode}{results=verbatim}
   TSreplace(x,  serIDs="gspc", Table="B", con=con)
\end{Scode}

and check the saved version:

\begin{Scode}{results=verbatim,fig=TRUE}
  TSrefperiod(TSget(serIDs="gspc", con=con)) 
  TSdescription("gspc", con=con) 
  TSdoc("gspc", con=con)
  TSlabel("gspc", con=con) # this is not yet supported on the db
  tfplot(TSget(serIDs="gspc", con=con))
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
   x <- TSget("ibm", quote = c("Close", "Vol"), con=Yahoo)
   TSreplace(x, serIDs=c("ibm.Cl", "ibm.Vol"),  con=con, Table="B",
              TSdescription.=c("IBM Close","IBM  Volume"),
	      TSdoc.= paste(c(
	         "IBM  Close   retrieved on ",
		 "IBM  Volume retrieved  on "), Sys.Date()))

   z <- TSget(serIDs=c("ibm.Cl", "ibm.Vol"), 
             TSdescription=TRUE, TSdoc=TRUE, con=con)
   TSdescription(z)
   TSdoc(z)
   tfplot(z, xlab = TSdoc(z), Title = TSdescription(z))
   tfplot(z, Title="IBM", start="2007-01-01")
\end{Scode}

Oanda has maximum of 500 days, so the start date is specified here so as to
not exceed that.

\begin{Scode}{results=verbatim}
   Oanda <- TSconnect("histQuote", dbname="oanda") 
   x <- TSget("EUR/USD", start=Sys.Date() - 495, con=Oanda)
   TSreplace(x, serIDs="EUR/USD", Table="D", con=con)
\end{Scode}

Then check the saved version:

\begin{Scode}{results=verbatim,fig=TRUE}
   z <- TSget(serIDs="EUR/USD",TSlabel=TRUE, TSdescription=TRUE,  con=con)
   tfplot(z, Title = TSdescription(z), ylab=TSlabel(z))
   tfplot(z, Title = "EUR/USD", start="2007-01-01")
   tfplot(z, Title = "EUR/USD", start="2007-03-01")
   tfplot(z, Title = "EUR/USD", start=Sys.Date()-14, end=Sys.Date(),
      xlab = format(Sys.Date(), "%Y"))
\end{Scode}

\begin{Scode}{results=hide}
  dbDisconnect(con)
  dbDisconnect(Yahoo)
  dbDisconnect(Oanda)
\end{Scode}


\subsection{Examples  Using TSdbi with ets}

These examples use a database called "ets" which is available at the Bank
of Canada.
This set of examples illustrates how the programs might be used if a larger
database is available. Typically a large database would be installed using
database scripts directly rather than from R with \code{TSput} or
\code{TSreplace}. 

The following are wrapped in \code{if (!inherits(conets, "try-error"))} so that
the vignette will build even when the database is not available. This seems to
require an explicit call to \code{print()}, but that is not usually needed to
display results below. Another artifact of this is that results printed in the
if block do not display until the end of the block.

\begin{Scode}{results=verbatim,fig=TRUE}
  m <- dbDriver("PostgreSQL")
  conets <-  try(if ("" == user) TSconnect(m, dbname="ets", host=host) else
    TSconnect(m, dbname="ets", user=user, password=passwd, host=host))
  if (!inherits(conets, "try-error")) {
  
  options(TSconnection=conets)

  print(TSmeta("M.SDR.CCUSMA02.ST"))

  EXCH.IDs <- t(matrix(c(
 	"M.SDR.CCUSMA02.ST",	 "SDR/USD exchange rate",
 	"M.CAN.CCUSMA02.ST",	 "CAN/USD exchange rate",
 	"M.MEX.CCUSMA02.ST",	 "MEX/USD exchange rate",
 	"M.JPN.CCUSMA02.ST",	 "JPN/USD exchange rate",
 	"M.EMU.CCUSMA02.ST",	 "Euro/USD exchange rate",
 	"M.OTO.CCUSMA02.ST",	 "OECD /USD exchange rate",
 	"M.G7M.CCUSMA02.ST",	 "G7   /USD exchange rate",
 	"M.E15.CCUSMA02.ST",	 "Euro 15. /USD exchange rate"
	), 2, 8))

  print(TSdates(EXCH.IDs[,1]))
  z <- TSdates(EXCH.IDs[,1])
  print(start(z))
  print(end(z))
   
  tfplot(TSget(serIDs="V122646", conets))
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  print(TSdescription(TSget("V122646", TSdescription=TRUE)))
  print(TSdescription("V122646"))

  print(TSdoc(TSget("V122646", TSdoc=TRUE)))
  print(TSdoc("V122646"))

  tfplot(TSget("V122646", names="V122646", conets))
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  z <- TSget("V122646", TSdescription=TRUE)
  tfplot(z, Title=strsplit(TSdescription(z), ","))
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  z <- TSget("SDSP500", TSdescription=TRUE)
  tfplot(z, Title=TSdescription(z))
  plot(z)
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  z <- TSget(c("DSP500","SDSP500"), TSdescription=TRUE)
  tfplot(z, xlab=TSdescription(z))
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  plot(z)
  }
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
if (!inherits(conets, "try-error")) {
  ETSgdp    <- annualizedGrowth(aggregate(TSget("V1992067"),
                   nfrequency=4,FUN=mean), lag=4, names="GDP Y/Y Growth")
  tfplot(ETSgdp)
  }  # end if !try-error
\end{Scode}
  
\begin{Scode}{results=hide}
  if (!inherits(conets, "try-error")) {
  #dbDisconnect(conets)
  dbDisconnect(options()$TSconnection)
  options(TSconnection=NULL)
  }  # end if !try-error
\end{Scode}

\section{Examples Using DBI and direct SQL Queries}

The following examples are queries using the underlying "DBI" functions.
They should not often be needed to access time series, but may be useful
to get at more detailed information, or formulate special queries.

\begin{Scode}{results=hide}
 m <- dbDriver("PostgreSQL")
 con <-  if ("" == user) TSconnect(m, dbname="test", host=host) else
    TSconnect(m, dbname="test", user=user, password=passwd, host=host)
 options(TSconnection=con)
\end{Scode}


\begin{Scode}{results=verbatim}
dbListTables(con)
\end{Scode}


If schema queries  are supported then table information can be found in a
generic SQL way, but on some systems this will fail because users
do not have read priveleges on the INFORMATION\_SCHEMA table,
so the following are wrapped in \code{try()}.
(SQLite does not seem to support this at all.)

\begin{Scode}{results=verbatim}
  try( dbGetQuery(con, paste(
       "SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.Columns ",
       " WHERE TABLE_SCHEMA='test' AND table_name='A' ;"))  )

  try( dbGetQuery(con, paste(
       "SELECT COLUMN_NAME, COLUMN_DEFAULT, COLLATION_NAME, DATA_TYPE,",
       "CHARACTER_SET_NAME, CHARACTER_MAXIMUM_LENGTH, NUMERIC_PRECISION",
 "FROM INFORMATION_SCHEMA.Columns WHERE TABLE_SCHEMA='test' AND table_name='A' ;"))  )

  try( dbGetQuery(con, paste(
   "SELECT COLUMN_NAME, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH, NUMERIC_PRECISION",
 "FROM INFORMATION_SCHEMA.Columns WHERE TABLE_SCHEMA='test' AND table_name='M';"))  )

\end{Scode}

Finally, to disconnect gracefully, one should

\begin{Scode}{results=hide}

dbDisconnect(con)

dbDisconnect(options()$TSconnection)
options(TSconnection=NULL)
#dbUnloadDriver(m)
\end{Scode}


FROM TSSQLite

In SQLite  there does not seem to be any need to set user or password 
information, and examples here all use the localhost.

Once R is started, the functions in this package are made available with

\begin{Scode}
library("TSSQLite")  
\end{Scode}
This will also load required packages \pkg{TSdbi}, \pkg{DBI}, \pkg{RSQLite}, 
\pkg{methods}, and \pkg{tframe}. 
Some examples below also require \pkg{zoo}, and \pkg{tseries}.

The next small section of code is necessary to setup database tables that are
used in the examples below. It
needs to be done only once for a database and might typically be done by
an administrator setting up the database, rather than by an end user. 

\begin{Scode}{results=hide}
m <- dbDriver("SQLite")
con <- dbConnect(m, dbname="test") 
source(system.file("TSsql/CreateTables.TSsql", package = "TSdbi"))
dbDisconnect(con)
\end{Scode}

More detailed description of the
instructions for building the database tables is given in the vignette 
for the \pkg{TSdbi} package. Those instruction show how to build the database
using database utilites rather than R, which might be the way a
system administrator would build the database.

\section{Using the Database - TSdbi Functions}

This section gives several simple examples of putting series on and reading them
from the database. (If a large number of series are to be loaded into a database,
one would typically do this with a batch process using the database program's
utilities for loading data.)
The first thing to do is to establish a connection to the database:

\begin{Scode}{results=hide}
 m <- dbDriver("SQLite")
 con <- TSconnect(m, dbname="test") 
\end{Scode}

\code{TSconnect} uses \code{dbConnect} from the \pkg{DBI} package, but checks that the
database has expected tables, and checks for additional features. (It cannot
be used before the tables are created, as done in the previous section.)

This puts a series called \code{vec}  on the database and then reads is back
 
\begin{Scode}
 z <- ts(rnorm(10), start=c(1990,1), frequency=1)
 seriesNames(z) <- "vec"
 if(TSexists("vec", con)) TSdelete("vec", con) 
 TSput( z, con)
 z <- TSget("vec", con)
\end{Scode}
If the series is printed it is seen to be a "ts" time series with some extra
attributes.

\code{TSput} fails if the series already exists on the \code{con}, 
so the above example checks and deletes the series if it already exists. 
\code{TSreplace} does not fail if the series does
not yet exist, so examples below use it instead. Several plots below show
original data and the data retrieved after it is written to the database. One is
added to the original data so that both lines are visible.

And now more examples:

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(20),10,2), start=c(1990,1), frequency=1)
 seriesNames(z) <- c("matc1", "matc2")
 TSreplace(z, con)
 TSget("matc1", con)
 TSget("matc2", con)
 TSget(c("matc1","matc2"), con)
 require("tfplot")
 tfplot(z+1, TSget(c("matc1","matc2"), con), 
          lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(20),10,2), start=c(1990,1), frequency=4)
  seriesNames(z) <- c("matc1", "matc2")
 TSreplace(z, con)
 TSget(c("matc1","matc2"), con)
 tfplot(z+1, TSget(c("matc1","matc2"), con),
          lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(200),100,2), start=c(1995,1), frequency=12)
  seriesNames(z) <- c("mat2c1", "mat2c2")
 TSreplace(z, con)
 tfplot(z+1, TSget(c("mat2c1","mat2c2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}
 
The following extract information about the series from the database, although
not much information has been added for these examples. 
\begin{Scode}
 TSmeta("mat2c1", con)
 TSmeta("vec", con)
 TSdates("vec", con)
 TSdescription("vec", con)
 TSdoc("vec", con)
\end{Scode}

Below are exampoles that make more use of \code{TSdescription} and code{TSdoc}.

Often it is convenient to set the default connection:

\begin{Scode}
 options(TSconnection=con)
\end{Scode}
and then the \code{con} specification can be omitted from the function calls
unless another connection is needed. The \code{con} can still be specified, and
some examples below do specify it, just to illustrate the alternative syntax.

\begin{Scode}{results=verbatim}
 z <- TSget("mat2c1") 
 TSmeta("mat2c1")
\end{Scode}


Data documentation can be in two forms, a description specified by 
\code{TSdescription}
or longer documentation specified by \code{TSdoc}. These can be added to the time
series object, in which case they will be written to the database when
\code{TSput} or \code{TSreplace} is used to put the series on the database. 
Alternatively, they
can be specified as arguments to \code{TSput} or \code{TSreplace}.
The description or documentation will be retrieved as part of the series object
with \code{TSget} only if this is specified with the logical arguments
\code{TSdescription} and \code{TSdoc}. They can also be retrieved directly from the
database with the functions \code{TSdescription} and \code{TSdoc}.

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(10),10,1), start=c(1990,1), frequency=1)
 TSreplace(z, serIDs="Series1", con) 
 zz <- TSget("Series1", con)
 TSreplace(z, serIDs="Series1", con, 
     TSdescription="short rnorm series", 
     TSdoc="Series created as an example in the vignette.")
 zz <- TSget("Series1", con, TSdescription=TRUE, TSdoc=TRUE)
 start(zz)
 end(zz)
 TSdescription(zz)
 TSdoc(zz)

 TSdescription("Series1", con)
 TSdoc("Series1", con)

 z <- ts(rnorm(10), start=c(1990,1), frequency=1)
 seriesNames(z) <- "vec"
 TSreplace(z, con)
 zz <- TSget("vec", con)

 z <- ts(matrix(rnorm(20),10,2), start=c(1990,1), frequency=1)
 seriesNames(z) <- c("matc1", "matc2")
 TSreplace(z, con) 
 tfplot(z+1, TSget(c("matc1","matc2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))

\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(20),10,2), start=c(1990,1), frequency=4)
 seriesNames(z) <- c("matc1", "matc2")
 TSreplace(z, con)
 tfplot(z+1, TSget(c("matc1","matc2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))

\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- ts(matrix(rnorm(200),100,2), start=c(1995,1), frequency=12)
 seriesNames(z) <- c("mat2c1", "mat2c2")
 TSreplace(z, con) 
 tfplot(z+1, TSget(c("mat2c1","mat2c2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))
\end{Scode}

The following examples use dates and times which are not handled by \code{ts},
so the \pkg{zoo} time representation is used.

\begin{Scode}{results=verbatim,fig=TRUE}
require("zoo") 

 z <- zoo(matrix(rnorm(200),100,2), as.Date("1990-01-01") + 0:99)
  seriesNames(z) <- c("zooc1", "zooc2")
 TSreplace(z, con, Table="D")
 tfplot(z+1, TSget(c("zooc1","zooc2"), con),
           lty=c("solid", "dashed"), col=c("black", "red"))
  
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
 z <- zoo(matrix(rnorm(200),100,2), as.Date("1990-01-01") + 0:99 * 7)
  seriesNames(z) <- c("zooWc1", "zooWc2")
 TSreplace(z, con, Table="W")
 tfplot(z+1, TSget(c("zooWc1","zooWc2"), con), col=c("black", "red"),
    lty=c("dashed", "solid"))  
\end{Scode}

\begin{Scode}{results=hide}
 dbDisconnect(con)
 #dbUnloadDriver(m)
\end{Scode}

\section{Examples Using Web Data}

This section illustrates fetching data from a web server and loading it into the
database. This would be a very slow way to load a database, but provides
examples of different kinds of time series data. The fetching is done with 
\pkg{TShistQuote} which provides a wrapper for \code{get.hist.quote} from 
package \pkg{tseries} to give syntax consistent with the \pkg{TSdbi}.

Fetching data may fail due to lack of an Interenet connection or delays. 

First establish a connection to the database where data will be saved:
\begin{Scode}
con <- TSconnect("SQLite", dbname="test")
\end{Scode}

Now connect to the web server and fetch data:

\begin{Scode}{results=verbatim}
  require("TShistQuote")
  Yahoo <- TSconnect("histQuote", dbname="yahoo") 
  x <- TSget("^gspc", quote = "Close", con=Yahoo)
  plot(x)
  tfplot(x)

  TSrefperiod(x) 
  TSdescription(x) 
  TSdoc(x) 
  TSlabel(x) 
\end{Scode}

Then write the data to the local server, specifying table B for business day 
data (using TSreplace in case the series
is already there from running this example previously):

\begin{Scode}{results=verbatim}
   TSreplace(x,  serIDs="gspc", Table="B", con=con)
\end{Scode}

and check the saved version:

\begin{Scode}{results=verbatim,fig=TRUE}
  TSrefperiod(TSget(serIDs="gspc", con=con)) 
  TSdescription("gspc", con=con) 
  TSdoc("gspc", con=con)
  TSlabel("gspc", con=con) # this is not yet supported on the db
  tfplot(TSget(serIDs="gspc", con=con))
\end{Scode}

\begin{Scode}{results=verbatim,fig=TRUE}
   x <- TSget("ibm", quote = c("Close", "Vol"), con=Yahoo)
   TSreplace(x, serIDs=c("ibm.Cl", "ibm.Vol"),  con=con, Table="B",
              TSdescription.=c("IBM Close","IBM  Volume"),
	      TSdoc.= paste(c(
	         "IBM  Close   retrieved on ",
		 "IBM  Volume retrieved  on "), Sys.Date()))

   z <- TSget(serIDs=c("ibm.Cl", "ibm.Vol"), 
             TSdescription=TRUE, TSdoc=TRUE, con=con)
   TSdescription(z)
   TSdoc(z)
   tfplot(z, xlab = TSdoc(z), Title = TSdescription(z))
   tfplot(z, Title="IBM", start="2007-01-01")
\end{Scode}

Oanda has maximum of 500 days, so the start date is specified here so as to
not exceed that.

\begin{Scode}{results=verbatim}
   Oanda <- TSconnect("histQuote", dbname="oanda") 
   x <- TSget("EUR/USD", start=Sys.Date() - 495, con=Oanda)
   TSreplace(x, serIDs="EUR/USD", Table="D", con=con)
\end{Scode}

Then check the saved version:

\begin{Scode}{results=verbatim,fig=TRUE}
   z <- TSget(serIDs="EUR/USD",TSlabel=TRUE, TSdescription=TRUE,  con=con)
   tfplot(z, Title = TSdescription(z), ylab=TSlabel(z))
   tfplot(z, Title = "EUR/USD", start="2007-01-01")
   tfplot(z, Title = "EUR/USD", start="2007-03-01")
   tfplot(z, Title = "EUR/USD", start=Sys.Date()-14, end=Sys.Date(),
      xlab = format(Sys.Date(), "%Y"))
\end{Scode}

\begin{Scode}{results=hide}
  dbDisconnect(con)
  dbDisconnect(Yahoo)
  dbDisconnect(Oanda)
\end{Scode}


\subsection{Examples  Using TSdbi with ets}

The database called "ets" is available at the Bank
of Canada. These examples are illustrated in the \code{TSMySQL} and
\code{TSpadi} packages, but ets is not yet implemented under \code{TSSQLite}.

\section{Examples Using DBI and direct SQL Queries}

The following examples are queries using the underlying "DBI" functions.
They should not often be needed to access time series, but may be useful
to get at more detailed information, or formulate special queries.

\begin{Scode}{results=hide}
 m <- dbDriver("SQLite")
 con <- TSconnect(m, dbname="test") 
 options(TSconnection=con)
\end{Scode}


\begin{Scode}{results=verbatim}
dbListTables(con)
\end{Scode}

If schema queries  are supported then table information can be obtained in a
(almost) generic SQL way. On some systems this will fail because users
do not have read priveleges on the INFORMATION\_SCHEMA table. This does not seem
to be an issue in SQLite, but I have not figured out the SQLite implementation
so the following are wrapped in \code{try()}.

\begin{Scode}{results=verbatim}
  try( dbGetQuery(con, paste(
       "SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.Columns ",
       " WHERE TABLE_SCHEMA='test' AND table_name='A' ;"))  )

  try( dbGetQuery(con, paste(
       "SELECT COLUMN_NAME, COLUMN_DEFAULT, COLLATION_NAME, DATA_TYPE,",
       "CHARACTER_SET_NAME, CHARACTER_MAXIMUM_LENGTH, NUMERIC_PRECISION",
 "FROM INFORMATION_SCHEMA.Columns WHERE TABLE_SCHEMA='test' AND table_name='A' ;"))  )

  try( dbGetQuery(con, paste(
   "SELECT COLUMN_NAME, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH, NUMERIC_PRECISION",
 "FROM INFORMATION_SCHEMA.Columns WHERE TABLE_SCHEMA='test' AND table_name='M';"))  )

\end{Scode}

Finally, to disconnect gracefully, one should

\begin{Scode}{results=hide}
dbDisconnect(options()$TSconnection)
options(TSconnection=NULL)
#dbUnloadDriver(m)
\end{Scode}

\end{document}
